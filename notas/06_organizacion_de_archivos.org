#+SETUPFILE: ../setup_notas.org
#+TITLE: Archivos y directorios: Organización de archivos

* Introducción
#<<DIR>>

De los papeles que cumple el sistema operativo, probablemente el que
más consciente tengan en general sus usuarios es el de la gestión del
espacio de almacenamiento, esto es, la organización de la información
en un /sistema de archivos/. Al día de hoy, todos los usuarios de
equipo de cómputo dan por sentado y comprenden a grandes rasgos la
organización del espacio de almacenamiento en un /directorio
jerárquico/, con unidades de almacenamiento llamadas /archivos/, de
diferentes tipos según su función. En el presente capítulo se revisará
la semántica que compone a este modelo, para que en el capítulo
\ref{FS} se continúe con los detalles de la gestión del espacio físico
donde éstos están alojados.

La abstracción que hoy se conoce como /sistemas de archivos/ es una de
las que más tiempo ha vivido y se ha mantenido a lo largo de la
historia de la computación, sobreviviendo a lo largo de prácticamente
todas las generaciones de sistemas operativos. Sin embargo, para poder
analizar cómo es que el sistema operativo representa la información en
el dispositivo físico, el presente capítulo inicia discutiendo cómo es
que esta información es comprendida por los niveles más altos —por los
programas en espacio de usuario.

#+attr_latex: height=0.5\textheight
#+label: DIR_capas_acceso_a_discos
#+caption: Capas de abstracción para implementar los sistemas de archivos.
[[./img/dot/capas_acceso_a_discos.png]]

La información /cruda/ tiene que pasar una serie de
transformaciones. Yendo de niveles superiores a los más bajos, un
programa estructura sus datos en /archivos/, siguiendo el /formato/
que resulte más pertinente al tipo de información a representar. Un
conjunto de archivos hoy en día es típicamente representado en una
estructura de /directorios/.[fn:: Se tienen otros mecanismos para su
organización, pero éstos no están tan ampliamente difundidos.]

Cada dispositivo empleado para almacenar archivos tiene un directorio.
Cuando un sistema opera con más de un dispositivo físico, hay
principalmente dos mecanismos para integrar a dichos dispositivos en
un /sistema de archivos virtual/,[fn:: Esto será abordado en la
sección \ref{DIR_montaje_directorios}.] brindando al usuario una
interfaz uniforme. Por último, los archivos son una estructura
meramente lógica; deben ser convertidos para ser representados en un
/dispositivo de bloques/ como los diversos tipos de unidades –aunque
esta nomenclatura es a veces incorrecta– como /discos/. Este último
paso será abordado en el capítulo \ref{FS}.

Del diagrama presentado en la figura \ref{DIR_capas_acceso_a_discos},
toca al objeto de estudio de esta obra –el sistema operativo– recibir del
espacio de usuario las llamadas al sistema que presentan la interfaz
de archivos y directorios, integrar el sistema de archivos virtual y
traducir la información resultante a un sistema de archivos.

Cabe mencionar que varias de las capas aquí presentadas podrían
perfectamente ser subdivididas, analizadas por separado, e incluso
tratarse de forma completamente modular —de hecho, este es
precisamente el modo en que se implementan de forma transparente
características hoy en día tan comunes como sistemas de archivos en
red, o compresión y cifrado de la información. Una referencia más
detallada acerca de ventajas, desventajas, técnicas y mecanismos de la
división y comunicación entre capas puede ubicarse en
\parencite{Heidemann1994}.

* Concepto de archivo

En primer término, un archivo es un /tipo de datos abstracto/ —esto
es, podría verse como una estructura que exclusivamente permite la
manipulación por medio de una interfaz /orientada a objetos/: los
procesos en el sistema sólo pueden tener acceso a los archivos por
medio de la interfaz ofrecida por el sistema operativo.[fn:: Como se
verá en la sección \ref{FS_volumenes_crudos}, esto no es
/necesariamente/ así, sin embargo, el uso de los dispositivos /en
crudo/ es muy bajo. Este capítulo está enfocado exclusivamente al uso
estructurado en sistemas de archivos.] La siguiente sección describe
las principales operaciones provistas por esta interfaz.

Para el usuario, los archivos son la /unidad lógica mínima/ al hablar
de almacenamiento: todo el almacenamiento /persistente/ (que sobrevive
en el tiempo, sea a reinicios del sistema, a pérdida de corriente o a
otras circunstancias en el transcurso normal de ejecución) en el
sistema al que tiene acceso, se efectúa dentro de archivos; el espacio
libre en los diferentes dispositivos no tiene mayor presencia fuera
de saber que está /potencialmente/ disponible.

Dentro de cada /volumen/ (cada medio de almacenamiento), los archivos
disponibles conforman un /directorio/, y son típicamente
identificados por un /nombre/ o una /ruta/. Más adelante se
presentarán de las diferentes construcciones semánticas que pueden
conformar a los directorios.

** Operaciones con archivos
#<<DIR_operaciones_con_archivos>>

Cada sistema operativo definirá la interfaz de archivos acorde con su
semántica, pero en líneas generales, las operaciones que siempre
estarán disponibles con un archivo son:

- Borrar :: Elimina al archivo del directorio y, de ser procedente,
            libera el espacio del dispositivo

- Abrir :: Solicita al sistema operativo verificar si el archivo existe o
	   puede ser creado (dependiendo del modo requerido) y se cuenta con el
           acceso para el /modo de acceso/ al archivo indicado y
           si el medio lo soporta (por ejemplo, a pesar de contar con
           todos los permisos necesarios, el sistema operativo no debe
           permitir abrir para escritura un archivo en un *cd-rom* u
           otro medio de sólo lectura). En C, esto se hace con la
           función =fopen()=.

	   Al abrir un archivo, el sistema operativo asigna un
           /descriptor de archivo/ que identifica la relación entre
           el proceso y el archivo en cuestión; éstos serán definidos
           propiamente en la sección \ref{DIR_tablas_de_archivos}.

	   Todas las operaciones descritas a continuación operan sobre
           el descriptor de archivo, no con su nombre o ruta.

- Cerrar :: Indica al sistema que /el proceso en cuestión/ terminó de
            trabajar con el archivo; el sistema entonces debe escribir
            los buffers a disco y eliminar la entrada que representa a
            esta combinación archivo-proceso de las tablas activas,
            invalidando al /descriptor de archivo/. En C, para cerrar
            un descriptor de archivo se usa =fclose()=.

	    Dado que todas las operaciones se realizan por medio del
            descriptor de archivo, si un proceso cierra un archivo y
            requiere seguir utilizándolo, tendrá que abrirlo de nuevo
            para obtener un nuevo descriptor.

- Leer :: Si se solicita al sistema la lectura leer de un archivo
          hacia determinado buffer, éste copia el siguiente /pedazo/
          de información al. Este /pedazo/ podría ser una línea o
          un bloque de longitud definida, dependiendo del modo en que
          se solicite la lectura. El sistema mantiene un apuntador a
          la última posición leída, para poder /continuar/ con la
          lectura de forma secuencial.

	  La función que implementa la lectura en C es =fread()=. Cabe
          mencionar que =fread()= entrega el /número de caracteres/
          especificado; para trabajar con líneas de texto hace falta
          hacerlo mediante bibliotecas que implementen esta
          funcionalidad, como =readline=.

- Escribir :: Teniendo un archivo abierto, guarda información en
              él. Puede ser que escriba desde su primer posición
              (/truncando/ al archivo, esto es, borrando toda la
              información que pudiera ya tener), o /agregando/ al
              archivo, esto es, iniciando con el apuntador de
              escritura al final del mismo. La función C para escribir a
              un descriptor de archivo es =fwrite()=.

- Reposicionar :: Tanto la lectura como la escritura se hacen
                  siguiendo un /apuntador/, que indica cuál fue la
                  última posición del archivo a la que accesó el
                  proceso actual. Al reposicionar el apuntador, se
                  puede /saltar/ a otro punto del archivo. La función
                  que reposiciona el apuntador dentro de un descriptor
                  de archivos es =fseek()=.

Hay varias otras operaciones comunes que pueden implementarse con
llamadas compuestas a estas operaciones (por ejemplo, /copiar/ un
archivo puede verse como /crear/ un archivo nuevo en modo de
escritura, abrir en modo de lectura al archivo fuente, e ir /leyendo/
de éste y /escribiendo/ al nuevo hasta llegar al fin de archivo
fuente).

Las operaciones aquí presentadas no son todas las operaciones
existentes; dependiendo del sistema operativo, habrá algunas
adicionales; estas se presentan como una base general común a los
principales sistemas operativos.

Vale la pena mencionar que esta semántica para el manejo de archivos
presenta a cada archivo como si fuera una /unidad de cinta/, dentro de
la cual la cabeza lectora/escritora simulada puede avanzar o
retroceder.

** Tablas de archivos abiertos
# <<DIR_tablas_de_archivos>>

Tanto el sistema operativo como cada uno de los procesos mantienen
normalmente /tablas de archivos abiertos/. Éstas mantienen información
acerca de todos los archivos actualmente abiertos, presentándolos
hacia el proceso por medio de un /descriptor de archivo/; una vez que
un archivo fue abierto, las operaciones que se realizan dentro de éste
no son empleando su nombre, sino su descriptor de archivo.

En un sistema operativo multitareas, más de un proceso podría abrir el
mismo archivo a la vez; lo que cada uno de ellos pueda hacer, y cómo
esto repercute en lo que vean los demás procesos, depende de la semántica
que implemente el sistema; un ejemplo de las diferentes semánticas
posibles es el descrito en la sección \ref{DIR_bloq_arch}.

Ahora, ¿por qué estas tablas se mantienen tanto por el sistema
operativo como por cada uno de los procesos, no lleva esto a una
situación de información redundante?

La respuesta es que la información que cada uno debe manejar es
distinta. El sistema operativo necesita:

- Conteo de usuarios del archivo :: Requiere saberse cuántos procesos
     están empleando en todo momento a determinado archivo. Esto
     permite, por ejemplo, que cuando el usuario solicite /desmontar/
     una partición (puede ser para expulsar una unidad removible) o
     eliminar un archivo, el sistema debe poder determinar cuándo es
     momento de declarar la solicitud como /efectuada/. Si algún
     proceso tiene abierto un archivo, y particularmente si tiene
     cambios pendientes de guardar, el sistema debe hacer lo posible
     por evitar que el archivo /desaparezca/ de su visión.
- Modos de acceso :: Aunque un usuario tenga permisos de acceso a
     determinado recurso, el sistema puede determinar negarlo si
     llevaría a una inconsistencia. Por ejemplo, si dos procesos abren
     un mismo archivo en modo de escritura, es probable que los
     cambios que realice uno sobreescriban a los que haga el otro.
- Ubicación en disco :: El sistema mantiene esta información 
     para evitar que cada proceso tenga que
     consultar las tablas en disco para encontrar al archivo, o cada
     uno de sus fragmentos.
- Información de bloqueo :: En caso de que los modos de acceso del
     archivo requieran protección mutua, puede hacerlo por medio de un
     bloqueo.

Por otro lado, el proceso necesita:

- Descriptor de archivo :: Relación entre el nombre del archivo
     abierto y el identificador numérico que maneja internamente el
     proceso. Un archivo abierto por varios procesos tendrá
     descriptores de archivo distintos en cada uno de ellos.

     Al detallar la implementación, el descriptor de archivo otorgado
     por el sistema a un proceso es simplemente un número entero, que
     podría entenderse como /el n-ésimo archivo empleado por el
     proceso/.[fn:: No sólo los archivos reciben descriptores de
     archivo. Por ejemplo, en todos los principales sistemas
     operativos, los descriptores 0, 1 y 2 están relacionados a
     /flujos de datos/: respectivamente, la entrada estándar
     (=STDIN=), la salida estándar (=STDOUT=) y el error estándar
     (=STDERR=); si el usuario no lo indica de otro modo, la terminal
     desde donde fue ejecutado el proceso.]

- Permisos :: Los modos válidos de acceso para un archivo. Esto no
              necesariamente es igual a los permisos que tiene el
              archivo en cuestión en disco, sino que el /subconjunto/
              de dichos permisos bajo los cuales está operando para
              este proceso en particular —si un archivo fue abierto
              en modo de sólo lectura, por ejemplo, este campo
              únicamente permitirá la lectura.

** Acceso concurrente: bloqueo de archivos
# <<DIR_bloq_arch>>

Dado que los archivos pueden emplearse como mecanismo de comunicación
entre procesos que no guarden relación entre sí, incluso a lo largo
del tiempo, y para emplear un archivo basta indicar su nombre o ruta,
los sistemas operativos multitarea implementan mecanismos de bloqueo
para evitar que varios procesos intentando emplear de forma
concurrente a un archivo se corrompan mutuamente.

Algunos sistemas operativos permiten establecer bloqueos sobre
determinadas regiones de los archivos, aunque la semántica más común
es operar sobre el archivo entero.

En general, la nomenclatura que se sigue para los bloqueos es:

- Compartido :: (/Shared lock/) Podría verse como equivalente a un
                bloqueo (o /candado/) para realizar lectura — varios
                procesos pueden adquirir al mismo tiempo un bloqueo de
                lectura, e indica que todos los que posean dicho
                /candado/ tienen la expectativa de que el archivo no
                sufrirá modificaciones.
- Exclusivo :: (/Exclusive lock/) Un bloqueo o /candado/ exclusivo
               puede ser adquirido por un sólo proceso, e indica que
               realizará operaciones que modifiquen al archivo (o, si
               la semántica del sistema operativo permite expresarlo,
               a la /porción/ del archivo que indica).

Respecto al /mecanismo/ de bloqueo, hay también dos tipos,
dependiendo de qué tan explícito tiene que ser su manejo:

- Mandatorio u obligatorio :: (/Mandatory locking/) Una vez que un
     proceso adquiere un candado obligatorio, el sistema operativo se
     encargará de imponer las restricciones corresponidentes de acceso
     a todos los demás procesos, independientemente de si éstos fueron
     programados para considerar la existencia de dicho bloqueo o no.
- Consultivo o asesor :: (/Advisory locking/) Este tipo de bloqueos
     es manejado cooperativamente entre los procesos involucrados, y
     depende del programador de /cada uno/ de los programas en
     cuestión el solicitar y respetar dicho bloqueo.

Haciendo un paralelo con los mecanismos presentados en el capítulo
\ref{PROC}, los mecanismos que emplean mutexes, semáforos o variables
de condición serían /consultivos/, y únicamente los que emplean
monitores (en que la única manera de llegar a la información es por
medio del mecanismo que la protege) serían /mandatorios/.

No todos los sistemas operativos implementan las cuatro posibles
combinaciones (compartido mandatorio, o compartido consultivo,
exclusivo mandatorio y exclusivo consultivo). Como regla general, en
los sistemas Windows se maneja un esquema de bloqueo obligatorio, y en
sistemas Unix es de bloqueo consultivo.[fn:: Esto explica el que en
Windows sea tan común que el sistema mismo rechace hacer determinada
operación porque /el archivo está abierto por otro programa/ (bloqueo
mandatorio compartido), mientras que en Unix esta responsabilidad
recae en cada uno de los programas de aplicación.]

Cabe mencionar que el manejo de bloqueos con archivos requiere del
mismo cuidado que el de bloqueo por recursos cubierto en la
sección \ref{PROC_bloq_mutuos}: dos procesos intentando adquirir un
candado exclusivo sobre dos archivos pueden caer en un bloqueo mutuo
tal como ocurre con cualquier otro recurso.

** Tipos de archivo
# <<DIR_tipos_archivo>>

Si los archivos son la /unidad lógica mínima/ con la que se puede
guardar información en almacenamiento secundario, naturalmente sigue
que hay archivos de diferentes tipos: cada uno podría ser un documento
de texto, un binario ejecutable, un archivo de audio o video, o un
larguísimo etcetera, e intentar emplear un archivo como uno de un tipo
distinto puede resultar desde una frustración al usuario porque el
programa no responde como éste quiere, hasta en pérdidas
económicas.[fn:: Por ejemplo, imprimir un archivo binario resulta en
una gran cantidad de hojas inútiles, particularmente tomando en cuenta
que hay caracteres de control como el *ascii* 12 (avance de forma,
/form feed/), que llevan a las impresoras que operan en modo texto a
iniciar una nueva página; llevar a un usuario a ejecutar un archivo
ejecutable /disfrazado/ de un documento inocuo, como se verá a
continuación, fue un importante vector de infección de muchos virus.]

Hay tres estrategias principales para que el sistema operativo
reconozca el tipo de un archivo:

- Extensión :: En los sistemas *cp/m* de los setenta, el nombre de
               cada archivo se dividía en dos porciones, empleando
               como elemento separador al punto: el nombre del archivo
               y su extensión. El sistema mantenía una lista de
               extensiones conocidas, para las cuales sabría cómo
               actuar, y este diseño se propagaría a las aplicaciones,
               que sólo abrirían a aquellos archivos cuyas extensiones
               supieran manejar.

	       Esta estrategia fue heredada por *vms* y *ms-dos*, de
               donde la adoptó Windows; ya en el contexto de un
               entorno gráfico, Windows agrega, más allá de las
               extensiones directamente ejecutables, la relación de
               extensiones con los programas capaces de trabajar con
               ellas, permitiendo invocar a un programa con sólo dar
               ``doble clic'' en un archivo.

	       Como nota, este esquema de asociación de tipo de
               archivo permite ocultar las extensiones toda vez que ya
               no requieren ser del conocimiento del usuario, sino que
               son gestionadas por el sistema operativo, abre una vía
               de ataque automatizado que se popularizó en su momento:
               el envío de correos con extensiones engañosas
               duplicadas, esto es, el programa maligno (un /programa
               troyano/) se envía a todos los contactos del usuario
               infectado, presentándose por ejemplo como una imágen,
               con el nombre =inocente.png.exe=. Por el esquema de
               ocultamiento mencionado, éste se presenta al usuario
               como =inocente.png=, pero al abrirlo, el sistema
               operativo lo reconoce como un ejecutable, y lo ejecuta
               en vez de abrirlo en un visor de imágenes.

- Números mágicos :: La alternativa que emplean los sistemas Unix es,
     como siempre, simple y /elegante/, aunque indudablemente presenta
     eventuales lagunas: el sistema mantiene una lista compilada de
     las /huellas digitales/ de los principales formatos que debe
     manejar,[fn:: Una de las ventajas de este esquema es que cada
     administrador de sistema puede ampliar la lista con las huellas
     digitales que requiera localmente.] para reconocer el contenido
     de un archivo basado en sus primeros bytes.

     Casi todos los formatos de archivo incluyen lo necesario para que
     se lleve a cabo este reconocimiento, y cuando no es posible
     hacerlo, se intenta por medio de ciertas reglas /heurísticas/.
     Por ejemplo, todos los archivos de imágen en /formato de
     intercambio gráfico/ (*gif*) inician con la cadena =GIF87a= o
     =GIF89a=, dependiendo de la versión; los archivos del lenguaje de
     descripción de páginas PostScript inician con la cadena =%!=, el
     /Formato de Documentos Portátiles/ (*pdf*) con =%PDF=, un
     documento en formatos definidos alrededor de *xml* inicia con
     =<!DOCTYPE=, etcétera.  Algunos de estos formatos no están
     /anclados/ al inicio, sino en un punto específico del primer
     bloque.

     Un caso especial de números mágicos es el llamado /hashbang/
     (=#!=). Esto indica a un sistema Unix que el archivo en cuestión
     (típicamente un archivo de texto, incluyendo código fuente en
     algún lenguaje de /script/) debe tratarse como un ejecutable, y
     empleando como /intérprete/ al comando indicado inmediatamente
     después del /hashbang/. Es por esto que se pueden ejecutar
     directamente, por ejemplo, los archivos que inician con
     =#!/usr/bin/bash=: el sistema operativo invoca al programa
     =/usr/bin/bash=, y le especifica como argumento al archivo en
     cuestión.

- Metadatos externos :: Los sistemas de archivos empleado por las
     Apple Macintosh desde 1984 separan en dos /divisiones/ (/forks/)
     la información de un archivo: los datos que propiamente
     constituyen al archivo en cuestión son la /división de datos/
     (/data fork/), y la información /acerca del archivo/ se guardan
     en una estructura independiente llamada /división de recursos/
     (/resource fork/).

     Esta idea resultó fundamental para varias de las características
     /amigables al usuario/ que presentó Macintosh desde su
     introducción, particularmente, para presentar un entorno gráfico
     que respondiera ágilmente, sin tener que buscar los datos base de
     una aplicación dentro de un archivo de mucho mayor tamaño. La
     /división de recursos/ cabe en pocos sectores de disco, y si se
     toma en cuenta que las primeras Macintosh funcionaban únicamente
     con discos flexibles, el tiempo invertido en leer una lista de
     iconos podría ser demasiada.

     La división de recursos puede contener todo tipo de
     información; los programas ejecutables son los que le dan un
     mayor uso, dado que incluyen desde los aspectos gráficos (icono
     a mostrar para el archivo, ubicación de la ventana a ser
     abierta, etc.) hasta aspectos funcionales, como la traducción de
     sus cadenas al lenguaje particular del sistema en que está
     instalado. Esta división permite una gran flexibilidad, dado que
     no es necesario tener acceso al fuente del programa para crear
     traducciones y temas.

     En el tema particular que concierne a esta sección, la división
     de recursos incluye un campo llamado /creador/, que indica cuál
     programa fue el que generó al archivo. Si el usuario solicita
     ejecutar un archivo de datos, el sistema operativo lanzaría al
     programa /creador/, indicándole que abra al archivo en cuestión.

     Las versiones actuales de
     #+latex: Mac\textbf{os}
     #+html: Mac<b>os</b>
     ya no emplean esta técnica, sino
     que una llamada /appDirectory/, para propósitos de esta
     discusión, la técnica base es la misma.

** Estructura de los archivos y métodos de acceso
# <<DIR_archivos_estructurados>>

La razón principal del uso de sistemas de archivos son, naturalmente,
/los archivos/. En estos se almacena información de /algún tipo/, con
o sin una estructura predeterminada.

La mayor parte de los sistemas operativos maneja únicamente archivos
/sin estructura/ —cada aplicación es responsable de preparar la
información de forma congruente, y la responsabilidad del sistema
operativo es únicamente entregarlo como un conjunto de
bytes. Históricamente, hubo sistemas operativos, como *ibm cics*
(1968), *ibm mvs* (1974) o *dec vms* (1977), que administraban ciertos
tipos de datos en un formato básico de /base de datos/.

El hecho de que el sistema operativo no imponga estructura a un archivo no
significa, claro está, que la aplicación que lo genera no lo haga. La
razón por la que los sistemas creados en los últimos 30 años no han
implementado este esquema de base de datos es que le /resta/
flexibilidad al sistema: el que una aplicación tuviera que ceñirse a
los tipos de datos y alineación de campos del sistema operativo
impedía su adecuación, y el que la funcionalidad de un archivo tipo
base de datos dependiera de la versión del sistema operativo creaba
un /acoplamiento/ demasiado rígido entre el sistema operativo y las
aplicaciones.

Esta práctica ha ido cediendo terreno para dejar esta responsabilidad
en manos de procesos independientes en espacio de usuario (como sería
un gestor de bases de datos tradicional), o de bibliotecas que
ofrezcan la funcionalidad de manejo de archivos estructurados (como en
el caso de
#+latex: \emph{\textbf{sql}ite},
#+html: <i><b>sql</b>ite</i>,
empleado tanto por herramientas de adquisición de datos de bajo nivel
como /systemtap/ como por herramientas tan de escritorio como el
gestor de fotografías /shotwell/ o el navegador /Firefox/).

En los sistemas derivados de *ms-dos* puede verse aún un remanente de
los archivos estructurados: en estos sistemas, un archivo puede ser
/de texto/ o /binario/. Un archivo de texto está compuesto por una
serie de caracteres que forman /líneas/, y la separación entre una
línea y otra constituye de un /retorno de carro/ (caracter *ascii* 13,
=CR=) seguido de un /salto de línea/ (caracter *ascii* 10, =LF=).[fn::
Esta lógica es herencia de las máquinas de escribir manuales, en que
el /salto de línea/ (avanzar el rodillo a la línea siguiente) era una
operación distinta a la del /retorno de carro/ (devolver la cabeza de
escritura al inicio de la línea). En la época de los teletipos, como
medida para evitar que se perdieran caracteres mientras la cabeza
volvía hasta la izquierda, se decidió separar el inicio de nueva línea
en los dos pasos que tienen las máquinas de escribir, para inducir una
demora que evitara la pérdida de información.]

El acceso a los archivos puede realizarse de diferentes maneras:

- Acceso secuencial :: Mantiene la semántica por medio de la cual
     permite leer de los archivos, de forma equivalente a como lo
     harían las unidades de cinta mencionadas en la sección
     \ref{DIR_operaciones_con_archivos}, y como lo ilustra la figura
     \ref{DIR_acceso_secuencial}:
     el mecanismo principal para leer o escribir es ir avanzando
     consecutivamente por los bytes que conforman al archivo hasta
     llegar a su final.

     Típicamente se emplea este mecanismo de lectura para leer a
     memoria código (programas o bibliotecas) o documentos, sean
     enteros o fracciones de los mismos. Para un contenido
     estructurado, como una base de datos, resultaría absolutamente
     ineficiente, dado que no se conoce el punto de inicio o
     finalización de cada uno de los registros, y probablemente sería
     necesario hacer /barridos secuenciales/ del archivo completo para
     cada una de las búsquedas.

#+attr_latex: width=\textwidth
#+label: DIR_acceso_secuencial
#+caption: Archivo de acceso secuencial.
[[./img/ditaa/acceso_secuencial.png]]

- Acceso aleatorio :: El empleo de gestores como /SQLite/ u otros
     muchos motores de base de datos más robustos no exime al usuario de
     pensar en el archivo como una tabla estructurada, como lo ilustra
     la figura \ref{DIR_acceso_aleatorio}. Si la única semántica por
     medio de la cual el sistema operativo permitiera trabajar con los
     archivos fuera la equivalente a una unidad de cinta, implementar
     el acceso a un punto determinado del archivo podría resultar
     demasiado costoso.

     Afortunadamente, que el sistema operativo no imponga registros de
     longitud fija no impide que /el programa gestor/ lo haga. Si en
     el archivo al cual apunta el descriptor de archivo =FD= hay $2~000$
     registros de 75 bytes cada uno y el usuario requiere recuperar el
     registro número 65 hacia el buffer =registro=, puede
     /reposicionar/ el apuntador de lectura al byte $65 \times 75 = 4~875$
     (=seek(FD, 4875)=) y leer los siguientes 75 bytes en
     =registro= (=read(FD, *registro, 75)=).

#+attr_latex: width=\textwidth
#+label: DIR_acceso_aleatorio
#+caption: Archivo de acceso aleatorio.
[[./img/ditaa/acceso_aleatorio.png]]

- Acceso relativo a índice :: En los últimos años se han popularizado
     los gestores de base de datos /débilmente estructurados/ u
     /orientados a documentos/, llamados genéricamente
     #+latex: \emph{No\textbf{sql}}.
     #+html: <i>No<b>sql</b></i>.
     Estos gestores pueden guardar registros de tamaño variable en
     disco, por lo que, como lo ilustra la figura
     \ref{DIR_acceso_relativo_a_indice}, no pueden encontrar la
     ubicación correcta por medio de los mecanismos de acceso
     aleatorio.

     Para implementar este acceso, se divide al conjunto de datos en
     dos secciones (incluso, posiblemente, en dos archivos
     independientes): la primer sección es una lista corta de
     identificadores, cada uno con el punto de inicio y término de
     los datos a los que apunta. Para leer un registro, se emplea
     acceso aleatorio sobre el índice, y el apuntador se avanza a la
     ubicación específica que se solicita.

     En el transcurso de un uso intensivo de esta estructura, dado que
     la porción de índice es muy frecuentemente consultada y
     relativamente muy pequeña, muy probablemente se mantenga completa
     en memoria, y el acceso a cada uno de los registros puede
     resolverse en tiempo muy bajo.

     La principal desventaja de este modelo de indexación sobre
     registros de longitud variable es que sólo resulta eficiente para
     contenido /mayormente de lectura/: cada vez que se produce una
     escritura y cambia la longitud de los datos almacenados, se va
     generando fragmentación en el archivo, y para resolverla
     frecuentemente se hace necesario suspender un tiempo la ejecución
     de todos los procesos que lo estén empleando (e invalidar, claro,
     todas las copias en caché de los índices). Ahora bien, para los
     casos de uso en que el comportamiento predominante sea de
     lectura, este formato tendrá la ventaja de no desperdiciar
     espacio en los campos nulos o de valor irrelevante para algunos
     de los registros, y de permitir la flexibilidad de registrar
     datos originalmente no contemplados sin tener que modificar la
     estructura.

     Es importante recalcar que la escritura en ambas partes de la
     base de datos (índice y datos) debe mantenerse con garantías de
     atomicidad — si se pierde la sincronía entre ellas, el resultado
     será una muy probable corrupción de datos.

#+attr_latex: width=\textwidth
#+label: DIR_acceso_relativo_a_indice
#+caption: Acceso relativo a índice: tabla con apuntadores al lugar justo en un archivo sin estructura.
[[./img/ditaa/acceso_relativo_a_indice.png]]

** Archivos especiales
# <<DIR_arch_especiales>>

Los sistemas de archivos son estructuras de tan fácil manejo y
comprensión que resulta natural que los diseñadores de sistemas
operativos buscaran aprovecharlos para presentar todo tipo de
estructuras, no sólo archivos. En este sentido, la máxima Unix, /todo
es un archivo/, resulta el ejemplo natural.

Este concepto fue brevemente presentado en la sección
\ref{HW_refiriendo}; complementando dicha sección, en un sistema Unix
estándar, un archivo puede pertenecer a las siguientes categorías:

- Archivo estándar :: Aunque suene obvio, el tipo básico de archivo
     es, precisamente, el archivo. Representa directamente la
     información que lo conforma. Su semántica de uso es la presentada
     en el transcurso de este capítulo.

- Objetos del sistema de archivos :: La información acerca del sistema
     de archivos se almacena también dentro de archivos, aunque su
     tratamiento es especial (con una reminiscencia de los sistemas
     históricos mencionados en la sección
     \ref{DIR_archivos_estructurados}): El sistema operativo oculta al
     archivo /real/, y gestiona su información procesada para que lo
     emplee el usuario. Este tipo de archivos puede referirse a
     directorios o a ligas simbólicas. Ambos se detallan en la sección
     \ref{DIR_concepto_directorio}.

- Dispositivos :: Permiten el acceso directo a un dispositivo
                  externo. Como fue presentado en la sección
                  \ref{HW_refiriendo}, pueden ser /de bloques/ o /de
                  caracteres/. El contenido del archivo son dos
                  números, el /mayor/ y el /menor/; tradicionalmente,
                  el mayor indica de qué clase de dispositivo se
                  trata, y el menor, la instancia de que se trata.

		  Por ejemplo, tanto los discos duros como sus
                  particiones llevan por número mayor el ocho; los
                  números menores para los duros son 0, 16,
                  32, 48. Cada uno de los discos puede tener hasta 15
                  particiones: 1 a 15, 17 a 31, etcétera.

- Comunicación entre procesos :: Los archivos pueden representar
     /tuberías nombradas/ y /sockets/. Ambos son mecanismos que
     permiten intercambiar información entre distintos procesos; la
     tubería nombrada es más sencilla de emplear, pero permite
     únicamente la comunicación unidireccional, en tanto que el socket
     permite comunicación bidireccional como si se tratara de una
     conexión por red.

** Transferencias orientadas a bloques

Un sistema de archivos es la representación que se da a un conjunto de
archivos y directorios sobre un /dispositivo de bloques/, esto es, un
dispositivo que, para cualquier transferencia solicitada desde o hacia
él, responderá con un bloque de tamaño predefinido.

Esto es, si bien el sistema operativo presenta una abstracción por
medio de la cual la lectura (=read()=) puede ser de un tamaño
arbitrario, todas las transferencias de datos desde cualquiera de los
discos serán de un múltiplo del tamaño de bloques, definido por el
hardware (típicamente 512 bytes).

Al leer, como en el ejemplo anterior, sólamente un registro
de 75 bytes, el sistema operativo lee el bloque completo y
probablemente lo mantiene en un caché en la memoria principal; si en
vez de una lectura, la operación efectuada fue una de escritura
(=write()=), y el sector a modificar no ha sido leído aún a
memoria (o fue leído hace mucho, y puede haber sido expirado del
caché), el sistema tendrá que leerlo nuevamente, modificarlo en
memoria, y volver a guardarlo a disco.

* Organización de archivos

Hasta este punto, el enfoque ha sido en qué es y cómo se maneja un
archivo. Sin embargo, no tendría sentido hablar de /sistemas de
archivos/ si no hubiera una gran cantidad de archivos. Es común que un
sólo medio de almacenamiento de un equipo de uso casero aloje
/decenas de miles/ de archivos, y en equipos dedicados, no está fuera
de lugar tener cientos o miles de veces tanto. Por lo tanto, se tiene que
ver también cómo organizar una gran cantidad de archivos.

** Evolución del concepto de /directorio/
# <<DIR_concepto_directorio>>

El concepto dominante en almacenamiento hoy en día es el de
/directorios jerárquicos/. Esto no siempre fue así; conviene revisar
brevemente su historia para explicar la razón de ciertos detalles de
implementación del esquema actualmente dominante.

*** Convenciones de nomenclatura

Cada sistema de archivos puede determinar cuántos y qué caracteres son
válidos para designar a uno de sus elementos, y cuáles son separadores
válidos. El caracter que se emplea para separar los elementos de un
directorio no es un estándar a través de todos los sistemas operativos
—los más comunes en uso hoy en día son la diagonal (=/=), empleada en
sistemas tipo Unix y derivados (incluyendo
#+latex: Mac\textbf{os x}
#+html: Mac<b>os x</b>
y Android), y la diagonal invertida ($\backslash$), empleada en *cp/m*
y derivados, incluyendo *ms-dos* y Windows.

Diversos sistemas han manejado otros caracteres (por ejemplo, el
#+latex: Mac\textbf{os}
#+html: Mac<b>os</b>
histórico empleaba los dos puntos, =:=), y aunque muchas veces los
mantenían ocultos del usuario mediante una interfaz gráfica rica,
los programadores siempre tuvieron que manejarlos explícitamente.

A lo largo del presente texto se empleará la diagonal (=/=) como
separador de directorios.

*** Sistema de archivos /plano/

Los primeros sistemas de archivos limitaban el concepto de directorio
a una representación plana de los archivos que lo conformaban, sin
ningún concepto de /jerarquía de directorios/ como el que hoy resulta
natural a los usuarios. Esto se debía, en primer término, a lo
limitado del espacio de almacenamiento de las primeras computadoras en
implementar esta metáfora (por lo limitado del espacio de
almacenamiento, los usuarios no dejaban sus archivos a largo plazo en
el disco, sino que los tenían ahí meramente mientras los requerían), y
en segundo término, a que no se había aún desarrollado un concepto de
separación, permisos y privilegios como el que poco después
aparecería.

En las computadoras personales los sistemas de archivos eran también
planos en un primer momento, pero por otra razón: en los sistemas
/profesionales/ ya se había desarrollado el concepto; al aparecer la
primer computadora personal en 1975, ya existían incluso las primeras
versiones de Unix diseñadas para trabajo en red. La prioridad en los
sistemas personales era mantener el código del sistema operativo
simple, mínimo. Con unidades de disco capaces de manejar entre 80 y
160 *kb*, no tenía mucho sentido implementar directorios — si un
usuario quisiera llevar a cabo una división temática de su trabajo, lo
colocaría en distintos /discos flexibles/. El sistema operativo *cp/m*
nunca soportó jerarquías de directorios, como tampoco lo hizo la
primer versión de *ms-dos*.[fn:: El soporte de jerarquías de
directorios fue introducido apenas en la versión 2.0 de dicho sistema
operativo, junto con el soporte a discos duros de 10 *mb*, acompañando
al lanzamiento de la *ibm pc* modelo *xt*.]

El sistema de archivos original de la Apple Macintosh, *mfs*, estaba
construido sobre un modelo plano, pero presentando la /ilusión/ de
directorios de una forma comparable a las etiquetas: eran
representados bajo /ciertas/ vistas (aunque notoriamente no en los
diálogos de abrir y grabar archivos), pero el nombre de cada uno de
los archivos tenía que ser único, dado que el directorio al que
pertenecía era básicamente sólo un atributo del archivo.

Y contrario a lo que dicta la intuición, el modelo de directorio plano
no ha desaparecido: el sistema de /almacenamiento en la nube/ ofrecido
por el servicio /Amazon S3/ (/simple storage service/, /servicio
simple de almacenamiento/) maneja únicamente /objetos/ (comparable con
la definición de /archivos/ que se ha venido manejando) y /cubetas/
(de cierto modo comparables con las /unidades/ o /volúmenes/), y
permite referirse a un objeto o un conjunto de éstos basado en
/filtros/ sobre el total que conforman una cubeta.

Conforme se desarrollen nuevas interfaces al programador o al usuario,
probablemente se popularicen más ofertas como la que hoy hace
Amazon S3. Al día de hoy, sin embargo, el esquema jerárquico sigue,
con mucho, siendo el dominante.

*** Directorios de profundidad fija

Las primeras implementaciones de directorios eran /de un sólo nivel/:
el total de archivos en un sistema podía estar dividido en
directorios, fuera por tipo de archivo (separando, por ejemplo,
programas de sistema, programas de usuario y textos del correo), por
usuario (facilitando una separación lógica de los archivos de un
usuario de pertenecientes a los demás usuarios del sistema)

El directorio /raíz/ (base) se llama en este esquema *mfd* (/master
file directory/, /directorio maestro de archivos/), y cada uno de los
directorios derivados es un *ufd* (/user file directory/, /directorio
de archivos de usuario/).

#+attr_latex: width=\textwidth
#+label: DIR_directorio_simple
#+caption: Directorio simple, limitado a un solo nivel de profundidad.
[[./img/dot/directorio_simple.png]]

Este esquema resuelve el problema principal del nombre global único:
antes de los directorios, cada usuario tenía que cuidar que los
nombres de sus archivos fueran únicos en el sistema, y ya teniendo
cada uno su propio espacio, se volvió una tarea mucho más simple. La
desventaja es que, si el sistema restringe a cada usuario a escribir
en su *ufd*, se vuelve fundamentalmente imposible trabajar en algún
proyecto conjunto: no puede haber un directorio que esté tanto dentro
de =usr1= como de =usr2=, y los usuarios encontrarán más dificil
llevar un proyecto conjunto.

*** Directorios estructurados en árbol

El siguiente paso natural para este esquema es permitir una /jerarquía
ilimitada/: en vez de exigir que haya una capa de directorios, se le
puede /dar la vuelta/ al argumento, y permitir que cada directorio
pueda contener a otros archivos o directorios anidados
arbitrariamente. Esto permite que cada usuario (y que el administrador
del sistema) estructure su información siguiendo criterios lógicos y
piense en el espacio de almacenamiento como un espacio a largo plazo.

#+attr_latex: width=\textwidth
#+label: DIR_directorio_arbol
#+caption: Directorio estucturado en árbol.
[[./img/dot/directorio_arbol.png]]

Junto con esta estructura nacen las /rutas de búsqueda/ (/search
path/): tanto los programas como las bibliotecas de sistema ahora
pueden estar en cualquier lugar del sistema de archivos. Al definirle
al sistema una /ruta de búsqueda/, el usuario operador puede
desentenderse del lugar exacto en el que está determinado programa —el
sistema se encargará de buscar en todos los directorios mencionados
los programas o bibliotecas que éste requiera.[fn:: La /ruta de
búsqueda/ refleja la organización del sistema de archivos en el
contexto de la instalación específica. Es común que la ruta de
búsqueda de un usuario estándar en Unix sea similar a
=/usr/local/bin:/usr/bin:/bin:~/bin= — esto significa que cualquier
comando que sea presentado es buscado, en el orden indicado, en los
cuatro directorios presentados (separados por el caracter =:=, la
notación =~= indica el directorio personal del usuario activo). En
Windows, es común encontrar la ruta de búsqueda
=c:\WINDOWS\system32;c:\WINDOWS= ]

*** El directorio como un /grafo dirigido/
# <<DIR_grafo_dirigido>>

Si bien parecería que muchos de los sistemas de archivos empleados
hoy en día pueden modelarse suficientemente con un árbol, donde hay un
sólo nodo raíz, y donde cada uno de los nodos tiene un sólo nodo
padre, la semántica que ofrecen es en realidad un /superconjunto
estricto/ de ésta: la de un grafo dirigido.

En un grafo dirigido como el presentado en la figura \ref{DIR_directorio_DAG}, un mismo nodo puede tener varios directorios
/padre/, permitiendo, por ejemplo, que un directorio de trabajo común
sea parte del directorio personal de dos usuarios. Esto es, /el mismo
objeto/ está presente en más de un punto del árbol.

#+attr_latex: width=0.6\textwidth
#+label: DIR_directorio_DAG
#+caption: Directorio como un /grafo dirigido acíclico/: el directorio =proyecto= está tanto en el directorio =/home/usr1= como en el directorio =/home/usr2=.
[[./img/dot/directorio_DAG.png]]

Un sistema de archivos puede permitir la organización como un /grafo
dirigido/, aunque es común que la interfaz que presenta al
usuario[fn:: Esta simplificación es simplemente una abstracción, y
contiene una pequeña mentira, que será desmentida en breve.] se
restrinja a un /grafo dirigido acíclico/: las ligas múltiples son
permitidas, siempre y cuando no generen un ciclo.

La semántica de los sistemas Unix implementa directorios como grafos
dirigidos por medio de dos mecanismos:

- Liga o enlace duro :: La entrada de un archivo en un directorio Unix
     es la relación entre la ruta del archivo y el /número de i-nodo/
     en el sistema de archivos.[fn:: El significado y la estructura de
     un i-nodo se abordan en el capítulo \ref{FS}.] Si a partir de un
     archivo en cualquier punto del árbol se crea una /liga dura/ a
     él, ésta es sencillamente otra entrada en el directorio apuntando
     al mismo /i-nodo/. Ambas entradas, pues, son el mismo archivo —no
     hay uno /maestro/ y uno /dependiente/.

     En un sistema Unix, este mecanismo tiene sólo dos restricciones:

  1. Sólo se pueden hacer ligas duras dentro del mismo volumen.

  2. No pueden hacerse ligas duras a directorios, sólo a
     archivos.[fn:: Formalmente, puede haberlas, pero sólo el
     administrador puede crearlas; en la sección
     \ref{DIR_dir_traversal} se cubre la razón de esta restricción al
     hablar de recorrer los directorios.]

- Liga o enlace simbólico :: Es un archivo /especial/, que meramente indica a
                    dónde apunta. El encargado de seguir este archivo
                    a su destino (esto es, de /resolver/ la liga
                    simbólica) es el sistema operativo mismo; un
                    proceso no tiene que hacer nada especial para
                    seguir la liga.

		    Una liga simbólica puede /apuntar/ a directorios,
                    incluso creando ciclos, o a archivos en otros
		    volúmenes.

		    Cuando se crea una liga simbólica, la liga y el
                    archivo son dos entidades distintas. Si bien
                    cualquier proceso que abra al archivo destino
                    estará trabajando con la misma entidad, en caso de
                    que éste sea renombrado o eliminado, la liga
                    quedará /rota/ (esto es, apuntará a una ubicación
                    inexistente).

Si bien estos dos tipos de liga son válidos también en los sistemas
Windows,[fn:: Únicamente en aquellos que emplean el sistema de archivos
que introdujo Windows *nt*, el *ntfs*, no en los que utilizan alguna
de las variantes de *fat*.] en dichos sistemas sigue siendo más común
emplear los /accesos directos/. Se denomina así a un archivo
(identificado por su extensión, =.lnk=), principalmente creado para
poder /apuntar/ a los archivos desde el escritorio y los menúes; si
un proceso solicita al sistema abrir el /acceso directo/, no obtendrá
al archivo destino, sino al acceso directo mismo.

Si bien el *api* de Win32 ofrece las funciones necesarias para emplear
las ligas, tanto duras como simbólicas, éstas no están reflejadas
desde la interfaz usuario del sistema — y son sistemas donde el
usuario promedio no emplea una interfaz programador, sino que una
interfaz gráfica. Las ligas, pues, no son más empleadas por /cuestión
cultural/: en sus comunidades de usuarios, nunca fueron frecuentes,
por lo cual se mantienen como conceptos empleados sólo por los
/usuarios avanzados/.

Ya con el conocimiento de las ligas, y reelaborando la figura
\ref{DIR_directorio_DAG} con mayor apego a la realidad: en los
sistemas operativos (tanto Unix como Windows), todo directorio tiene
dos entradas especiales: los directorios =.= y =..=, que aparecen tan
pronto como el directorio es creado, y resultan fundamentales para
mantener la /navegabilidad/ del árbol.

#+attr_latex: width=0.6\textwidth
#+label: DIR_directorio_DAG_completo
#+caption: Directorio como un /grafo dirigido/, mostrando los /enlaces ocultos/ al directorio actual =.= y al directorio /padre/ =..=
[[./img/dot/directorio_DAG_completo.png]]

Como se puede ver en la figura \ref{DIR_directorio_DAG_completo}, en
todos los directorios, =.= es una liga dura al mismo directorio, y
=..= es una liga al directorio /padre/ (de nivel jerárquico
inmediatamente superior). Claro está, como sólo puede
haber una liga =..=, un directorio enlazado desde dos lugares
distintos sólo apunta hacia uno de ellos con
su enlace =..=; en este caso, el directorio común =proyecto= está
dentro del directorio =/home/usr2=. La figura representa la /liga
simbólica/ desde =/home/usr1= como una línea punteada.

Hay una excepción a esta regla: el directorio raíz. En este caso,
tanto =.= como =..= apuntan al mismo directorio.

Esta es la razón por la cual no se puede tomar rigurosamente un
árbol de archivos como un /grafo dirigido acíclico/, ni en Windows
ni en Unix: tanto las entradas =.= (al apuntar al mismo directorio
donde están contenidas) como las entradas =..= (al apuntar al
directorio padre) crean ciclos.

** Operaciones con directorios
# <<DIR_oper_dirs>>
Al igual que los archivos, los directorios tienen una semántica básica
de acceso. Éstos resultan también tipos de datos abstractos con
algunas operaciones definidas. Muchas de las operaciones que pueden
realizarse con los directorios son análogas a las empleadas para los
archivos.[fn:: De hecho, en muchos sistemas de archivos los
directorios son meramente archivos de tipo especial, que son
presentados al usuario de forma distinta. En la sección
\ref{FS_el_directorio} se presenta un ejemplo.] Las operaciones
básicas a presentar son:

- Abrir y cerrar :: Como en el caso de los archivos un programa que
                    requiera trabajar con un directorio deberá
                    /abrirlo/ para hacerlo, y /cerrarlo/ cuando ya no
                    lo requiera. Para esto, en C, se emplean las
                    funciones =opendir()= y =closedir()=. Estas
                    funciones trabajan asociadas a un /flujo de
                    directorio/ (/directory stream/), que funciona de
                    forma análoga a un descriptor de archivo.

- Listado de archivos :: Para mostrar los archivos que conforman a un
     directorio, una vez que se abrió el directorio se /abre/, el
     programa /lee/ (con =readdir()=) cada una de sus entradas.  Cada
     uno de los resultados es una estructura =dirent= (/directory
     entry/, esto es, /entrada de directorio/), que contiene su nombre
     en =d_name=, un apuntador a su /i-nodo/ en =d_ino=, y algunos
     datos adicionales del archivo en cuestión.

     Para presentar al usuario la lista de archivos que conforman un
     directorio, podría hacerse:

     #+BEGIN_SRC c
       #include <stdio.h>
       #include <dirent.h>
       #include <sys/types.h>
       
       int main(int argc, char *argv[]) {
         struct dirent *archivo;
         DIR *dir;
         if (argc != 2) {
           printf("Indique el directorio a mostrar\n");
           return 1;
         }
         dir = opendir(argv[1]);
         while ((archivo = readdir(dir)) != 0) {
           printf("%s\t", archivo->d_name);
         }
         printf("\n");
         closedir(dir);
       }
     #+END_SRC

     Al igual que en al hablar de archivos se puede /reposicionar/
     (=seek()=) al descriptor de archivo, para /rebobinar/ el
     descriptor del directorio al principio del listado se emplea
     =rewinddir()=.

- Buscar un elemento :: Si bien en el transcurso del uso del sistema
     operativo resulta una operación frecuente que el usuario solicite
     el listado de archivos dentro de un directorio, es mucho más
     frecuente buscar a un archivo en particular. La llamada =fopen()=
     antes descrita efectúa una búsqueda similar a la presentada en el
     ejemplo de código anterior, claro está, deteniéndose cuando
     encuentra al archivo en cuestión.

- Crear, eliminar o renombrar un elemento :: Si bien estas operaciones
     se llevan a cabo sobre el directorio, son invocadas por medio de
     la semántica orientada a archivos: un archivo es creado con
     =fopen()=, eliminado con =remove()=, y renombrado con =rename()=.

*** Recorriendo los directorios
# <<DIR_dir_traversal>>

Es frecuente tener que aplicar una operación a todos los archivos
dentro de cierto directorio, por ejemplo, para agrupar un directorio
completo en un archivo comprimido, o para copiar todos sus contenidos
a otro medio; procesar todas las entradas de un directorio, incluyendo
las de sus subdirectorios, se denomina /recorrer el directorio/ (en
inglés, /directory traversal/).

Si se trabaja sobre un sistema de archivos plano, la operación de
recorrido completo puede realizarse con un programa tan simple como el
presentado en la sección anterior.

Al hablar de un sistema de profundidad fija, e incluso de un
directorio estructurado en árbol, la lógica se complica levemente,
dado que para recorrer el directorio es necesario revisar, entrada por
entrada, si ésta es a su vez un directorio (y en caso de que así sea,
entrar y procesar a cada uno de sus elementos). Hasta aquí, sin
embargo, se puede recorrer el directorio sin mantener estructuras
adicionales en memoria representando el estado.

Sin embargo, al considerar a los grafos dirigidos, se vuelve
indispensable mantener en memoria la información de todos los nodos
que ya han sido tocados —en caso contrario, al encontrar ciclo (incluso
si éste es creado por mecanismos como las /ligas simbólicas/),
se corre el peligro de entrar en un bucle infinito.

#+attr_latex: width=0.2\textwidth
#+label: DIR_arbol_para_recorrer
#+caption: Directorio basado en grafo dirigido que incluye ciclos.
[[./img/dot/dir_traversal.png]]

Para recorrer al directorio ilustrado como ejemplo en la figura
\ref{DIR_arbol_para_recorrer}, no bastaría tomar nota de las rutas de
los archivos conforme son recorridas —cada vez que los sean
procesados, su ruta será distinta.  Al intentar respaldar el
directorio =/home/jose/proyecto=, por ejemplo, el recorrido resultante
podría ser:

- =/home/jose/proyecto=
- =/home/jose/proyecto/miembros=
- =/home/jose/proyecto/miembros/jose=
- =/home/jose/proyecto/miembros/jose/proyectos=
- =/home/jose/proyecto/miembros/jose/proyectos/miembros=
- ...Y un etcétera infinito.

Para resolver esta situación, los programas que recorren directorios
en los sistemas de archivos /reales/ deben emplear un indexado basado
en /i-nodo/,[fn:: Que si bien no ha sido definido aún formalmente,
para esta discusión bastará saber que es un número único por volumen.]
que identifica sin ambigüedad a cada uno de los archivos. En el caso
presentado, si el i-nodo de =jose= fuera $10~543$, al consultar a los
miembros de =miembros= el sistema encontrará que su primer entrada
apunta al i-nodo $10~543$, por lo cual la registraría sólo como un
apuntador a datos /ya archivados/, y continuaría con la segunda
entrada del directorio, que apunta a =pedro=.

*** Otros esquemas de organización

Por más que el uso de sistemas de archivos basados en directorios
jerárquicos parece universal y es muy ampliamente aceptado, hay cada
vez más casos de uso que apuntan a que se pueda estar por dar la
bienvenida a una nueva metáfora de organización de archivos.

Hay distintas propuestas, y claro está, es imposible aún saber cuál
dirección obtendrá el favor del mercado —o, dado que no necesariamente
siga habiendo un modelo apto para todos los usos, de /qué/ segmento
del mercado.

** /Montaje/ de directorios
#<<DIR_montaje_directorios>>

Para trabajar con el contenido de un sistema de archivos, el sistema
operativo tiene que /montarlo/: ubicarlo en algún punto del árbol de
archivos visible al sistema y al usuario.

Es muy común, especialmente en los entornos derivados de Unix, que un
sistema operativo trabaje con distintos sistemas de archivos al mismo
tiempo. Esto puede obedecer a varias causas, entre las cuales se
encuentran:

- Distintos medios físicos :: Si la computadora tiene más de una
     unidad de almacenamiento, el espacio dentro de cada uno de los
     discos se maneja como un sistema de archivos indepentiente. Esto
     es especialmente cierto en la presencia de unidades removibles
     (*cd*, unidades *usb*, discos duros externos, etc.)

- Diferentes usos esperados :: Como se verá más adelante, distintos
     /esquemas de organización/ (esto es, distintos sistemas de
     archivos) presentan ventajas para diversos patrones de uso. Por
     ejemplo, tiene sentido que una base de datos resida sobre una
     organización distinta a la de los programas ejecutables (binarios) del
     sistema.

- Abstracciones de sistemas no-físicos :: El sistema operativo puede
     presentar diversas estructuras /con una estructura/ de sistema de
     archivos. El ejemplo más claro de esto es el sistema de archivos
     virtual =/proc=, presente en los sistemas Unix, que permite ver
     diversos aspectos de los procesos en ejecución (y, en Linux, del
     sistema en general). Los archivos bajo =/proc= no están en ningún
     disco, pero se presentan como si fueran archivos estándar.

- Razones administrativas :: El administrador del sistema puede
     emplear sistemas de archivos distintos para aislar espacios de
     usuarios entre sí: por ejemplo, para evitar que un exceso de
     mensajes enviados en la bitácora (típicamente bajo =/var/log=)
     saturen al sistema de archivos principal, o para determinar
     patrones de uso máximo por grupos de usuarios.

En los sistemas tipo Unix, el mecanismo para montar los archivos es el
de un árbol con /puntos de montaje/. Esto es, /todos los archivos y
directorios/ del sistema operativo están estructurados en /un
único árbol/. Cuando se solicita al sistema operativo /montar/ un
sistema de archivos en determinado lugar, éste se integra al árbol,
ocultando todo lo que el directorio en cuestión previamente
tuviera.[fn:: Hay implementaciones que exigen que el montaje se realice
exclusivamente en directorios vacíos; se tienen otras, como UnionFS, que
buscan seguir presentando una interfaz /de lectura/ a los objetos que
existían en el directorio previo al montaje, pero realizan las
escrituras únicamente en el sistema ya montado; estas complican
fuertemente algunos aspectos semánticos, por lo cual resultan poco
comunes.]

#+attr_latex: width=\textwidth
#+label: DIR_puntos_de_montaje
#+caption: Árbol formado del montaje de =sda1= en la raíz, =sda2= como =/usr=, =sdb1= como =/home=, y el directorio virtual =proc=.
[[./img/dot/puntos_de_montaje.png]]

La manera en que esto se presenta en sistemas Windows es muy
distinta. Ahí, cada uno de los volumenes /detectados/
recibe un /identificador de volumen/, y es montado automáticamente en
un sistema de directorio estructurado como árbol de un sólo nivel
representando a los dispositivos del sistema.[fn:: En realidad, este
árbol no sólo incluye a los volúmenes de almacenamiento, sino que a
los demás dispositivos del sistema, como los distintos puertos, pero
los /oculta/ de la interfaz gráfica.] Este árbol es presentado a
través de la interfaz gráfica (aunque este nombre no significa nada
para el *api* del sistema) como /Mi Computadora/.

Para especificar la /ruta completa/ a determinado archivo, se inicia
con el identificador del volumen. De este modo, la especificación absoluta de un archivo es
una cadena como =VOL:\Dir1\Dir2\Archivo.ext= — el caracter =:= separa
al volumen del árbol del sistema de archivos, y el caracter
$\backslash$ separa uno de otro a los directorios. Por convención, si
no se especifica la unidad, el sistema asumirá que se está haciendo
referencia a la /unidad actual/ (a grandes rasgos, la última unidad en
ser utilizada).

Los identificadores de volumen están preasignados, muchos de ellos
según un esquema heredado desde la época de las primeras *pc*: los
volúmenes =A= y =B= están reservados para las unidades de disco
flexible; =C= se refiere al disco duro de arranque, y las unidades
posteriores que va detectando el sistema son =D=, =E=, =F=, etcétera.

Es posible modificar esta nomenclatura y configurar a los discos para
estar en otra ubicación, pero muchas aplicaciones dependen ya de este
comportamiento y configuración específica.

#+attr_latex: width=0.9\textwidth
#+label: DIR_montaje_windows
#+caption: Jerarquía de dispositivos y volúmenes de archivos en un sistema Windows.
[[./img/dot/montaje_windows.png]]

* Control de acceso

Parte importante de la información que se almacena respecto a cada uno
de los archivos, directorios u otros objetos son sus permisos de
acceso. Éstos indican al sistema qué puede hacerse y qué no con cada
uno de los objetos, posiblemente diferenciando el acceso dependiendo
del usuario o clase de usuarios de que se trate.

Hay muchos esquemas de control de acceso; a continuación se presentan
tres esquemas, comenzando por el más simple, y avanzando hacia los más
complejos.

** Sistemas *fat*

El sistema de archivos *fat*[fn:: Recibe su nombre de las siglas de su
estructura fundamental, la /Tabla de Asignación de Archivos/, o /File
Allocation Table/.] fue diseñado a fines de los setenta, y al día de hoy
es muy probablemente el sistema de archivos más ampliamente utilizado
del mundo. Su diseño es suficientemente simple para ser incluido en
dispositivos muy limitados; esta simplicidad se demostrará al analizar
sus principales estructuras son analizadas en el capítulo \ref{FS}. Y
por otro lado, con sólo modificaciones relativamente menores a su
diseño original, ha logrado extenderse de un sistema pensado para
volúmenes de 150 *kb* hasta llegar a las decenas de gigabytes.

En cada una de las entradas del directorio en un sistema *fat*, el
byte número 12 almacena los siguientes /atributos/:

- Oculto :: Si está encendido, el archivo no se deberá mostrar al
            usuario en listados de directorio.

- Sólo lectura :: El sistema operativo debe evitar toda modificación
                  al archivo, esto es, rechazar las llamadas al
                  sistema que soliciten esta modificación.

- Sistema :: Como se explicará en la sección \ref{FS_tabla_fat}, un
             sistema de archivos *fat* tiende conforme se va utilizando
             a /fragmentar/ los archivos que almacena. La carga del
             sistema operativo tiene que realizarse empleando código
             lo más compacto y sencillo posible: sin siquiera tener
             conocimiento del sistema de archivos. Este atributo
             indica que el sistema operativo debe cuidar no mover ni
             fragmentar al archivo en cuestión.

- Archivado :: *ms-dos* incluía herramientas bastante sencillas para
               realizar respaldos; estas basaban su operación en este
               atributo: Conforme se realizaba un respaldo, todos los
               archivos iban siendo marcados como /archivados/. Y
               cuando un archivo era modificado, el sistema operativo
               retiraba este atributo. De esta manera, el siguiente
               respaldo contendría únicamente los archivos que habían
               sido modificados desde el respaldo anterior.

Estos atributos eran suficientes para las necesidades de un sistema de
uso personal de hace más de tres décadas. Sin embargo, y dado que está
reservado todo un byte para los atributos, algunos sistemas
extendieron los atributos cubriendo distintas necesidades. Estos
cuatro atributos son, sin embargo, la base del sistema.

Puede verse que, bajo *ms-dos*, no se hace diferencia entre /lectura/
y /ejecución/. Como se presentó en la sección \ref{DIR_tipos_archivo},
el sistema *ms-dos* basa la identificación de archivos en su
/extensión/. Y, claro, siendo un sistema concebido como /monousuario/,
no tiene sentido condicionar la /lectura/ de un archivo: el sistema
operativo siempre permitirá la lectura de cualquier archivo.

** Modelo tradicional Unix

El sistema Unix precede a *ms-dos* por una década. Sin embargo, su
concepción es de origen para un esquema multiusuario, con las
provisiones necesarias para que cada uno de ellos indique qué usuarios
pueden o no tener diferentes tipos de acceso a los archivos.

En Unix, cada uno de los usuarios pertenece a uno o más
/grupos/. Estos grupos son gestionados por el administrador del
sistema.

Cada objeto en el sistema de archivos describe sus permisos de acceso
por nueve bits, y con el identificador de su usuario y grupo
propietarios.

Estos bits están dispuestos en tres grupos de tres; uno para el
/usuario/, uno para el /grupo/, y uno para los /otros/.  Por último,
los tres grupos de tres bits indican si se otorga permiso de
/lectura/, /escritura/ y /ejecución/. Estos permisos son los mismos
que fueron presentados en la sección \ref{MEM_permisos}, relativos al
manejo de memoria.

Estos tres grupos de tres permiten suficiente /granularidad/ en el
control de acceso para expresar casi cualquier combinación requerida.

Por poner un ejemplo, si los usuarios =jose=, =pedro= y =teresa= están
colaborando en el desarrollo de un sistema de facturación, pueden
solicitar al administrador del sistema la creación de un grupo,
=factura=. Una vez creado el sistema, y suponiendo que el desarrollo
se efectúa en el directorio =/usr/local/factura/=, podrían tener
los siguientes archivos:

#+begin_example
$ ls -la /usr/local/factura/
drwxrwxr-x root   factura   4096 .
drwxr-xr-x root   root      4096 ..
-rw-r----- root   factura  12055 compilacion.log
-rwxrwxr-x pedro  factura 114500 factura
-rw-rw-r-- teresa factura  23505 factura.c
-rw-rw-r-- jose   factura   1855 factura.h
-rw-rw---- teresa factura  36504 factura.o
-rw-rw---- teresa factura  40420 lineamientos.txt
-rw-rw-r-- pedro  factura   3505 Makefile
#+end_example

Este ejemplo muestra que cada archivo puede pertenecer a otro de los
miembros del grupo.[fn:: Los archivos pertenecen al usuario que los
creó, a menos que su propiedad sea /cedida/ por el administrador a
otro usuario.] Para el ejemplo aquí mostrado, el usuario propietario
es menos importante que el grupo al que pertenece.

La ejecución sólo está permitida, para los miembros del grupo
=factura=, en el archivo =factura=: los demás archivos son ya sea el
código fuente que se emplea para /generar/ dicho archivo ejecutable, o
la información de desarrollo y compilación.

Respecto al acceso del resto de los usuarios (esto es, aquellos no
pertenecientes al grupo =factura=), todos tienen permiso de lectura
sobre todos los archivos a excepción del archivo intermedio de
compilación, =factura.o=, el documento de diseño, =lineamientos.txt=,
y la bitácora de compilación, =compilacion.log=

Este ejemplo muestra los directorios =.= y =..=, que fueron
presentados en la sección \ref{DIR_grafo_dirigido}. Para los
directorios, se emplea el mismo sistema de permisos; el permiso de
escritura indica quién puede crear o eliminar archivos dentro de él,
el de lectura indica qué usuarios pueden averiguar la lista de
archivos contenidos en dicho directorio, y el de ejecución indica qué
usuarios pueden /entrar/ al directorio. En este caso, todos los
usuarios pueden listar (leer) y ejecutar (entrar) al directorio, pero
únicamente el administrador =root= y los miembros del grupo =factura=
pueden modificar los archivos que contiene.

Claro está, el directorio =..= (que apunta de vuelta al directorio
padre, =/usr/local/=) es del sistema, y permite sólo la lectura y
ejecución a todos los usuarios (incluyendo al grupo =factura=).

En este punto, cabe recordar que, en un sistema Unix, los dispositivos
del sistema así como varios objetos virtuales (como las /tuberías/ de
comunicación entre procesos) son representados en el sistema de
archivos. Esto significa que, por medio de estos permisos, el
administrador del sistema puede indicar qué usuarios pueden tener
permisos de lectura o modificación sobre los diferentes componentes
hardware del sistema.

El esquema de permisos de Unix presenta algunas características
adicionales, como los bits *suid/sgid* o los /atributos extendidos/
que presentan ciertas implementaciones; se sugiere al lector
interesado referirse a las /páginas de manual/ de Linux para los
comandos =chmod= y =chattr=, respectivamente.

** Listas de control de acceso

Una de las desventajas del modelo tradicional de usuarios Unix es que
requiere de la intervención del administrador del sistema para cada
nuevo proyecto: el administrador del sistema tuvo que crear al grupo
=factura= antes de que pudiera realizarse ningún trabajo de forma
colaborativa. Además, encontrar la representación justa para indicar
un conjunto específico de permisos puede ser complicado. Dado que un
archivo no puede pertenecer a más de un grupo, puede hacerse necesario
crear conjuntos de grupos adicionales que intersectan aspectos
específicos: una salida muy poco elegante.

#+caption: Lista de control de acceso a un archivo en Windows 7: en esta vista, muestra que el grupo =SYSTEM= tiene permiso para todo tipo de acceso, con excepción del definido por /Permisos especiales/.
#+label: DIR_ACLs_Win7
#+attr_latex: width=0.7\textwidth
[[./img/acl_win7.png]]

Varios sistemas operativos, incluyendo particularmente a las versiones
de Windows derivadas del *nt*, han agregado /listas de control de
acceso/ (o *acl*, del inglés, /Access Control Lists/): cada uno de
los archivos tiene asociada una lista donde se indican los permisos
particulares que tendrá sobre éste cada usuario o grupo particular. La
figura \ref{DIR_ACLs_Win7} muestra un ejemplo de la definición del
control de acceso a un archivo en el sistema operativo /Windows 7/.

Si bien el modelo de listas de control de acceso brinda un control
mucho más fino sobre cada uno de los archivos, no está exento de
desventajas: en primer término, todos los permisos particulares que
tenga un archivo tienen que almacenarse junto con su /i-nodo/. Dado
que su longitud es variable, se representan como una estructura
adicional adjunta a los datos del archivo, y esto se traduce en un
tiempo de acceso ligeramente mayor.

En segundo término, resulta más difícil presentar un listado compacto
y completo de los permisos para todos los archivos en determinado
directorio. Realizar una evaluación /al vuelo/ de los controles de
acceso se vuelve más complejo para el administrador.

Por último, este esquema da lugar a ambigüedades, cuya política
de resolución debe establecerse /a priori/. Por ejemplo, si un usuario
pertenece a dos grupos distintos, uno de ellos con /aprobación
explícita/ para la escritura a cierto archivo, y otro con /denegación
explícita/ para la escritura al mismo, debe haber una política global
para resolver si el permiso será otorgado o rechazado. Estas políticas
no siempre resultan fáciles de comprender por los usuarios del
sistema.

* Sistemas de archivos remotos

Uno de los principales y primeros usos que se dio a la comunicación en
red fue el de compartir archivos entre computadoras independientes. En
un principio, esto se realizaba de forma /explícita/, con
transferencias manuales mediante de programas dedicados a ello, como
sería hoy en día el *ftp*.

Por otro lado, desde mediados de los ochenta, es posible realizar estas
transferencias de forma /implícita/ y /automática/, empleando
/sistemas de archivos sobre la red/ (o lo que es lo mismo, /sistemas
de archivos remotos/).  Éstos se presentan como caso particular de
la /abstracción de sistemas no-físicos/ que fueron mencionados en la sección
anterior: si bien el sistema operativo no tiene acceso /directo/ a los
archivos y directorios que le solicitará el usuario, por medio de los
módulos de red, sabe cómo obtenerlos y presentarlos /como si fueran
locales/.

Al hablar de sistemas de archivos en red, casi siempre se hará
siguiendo un /modelo cliente-servidor/. Estos términos no se refieren
a las prestaciones relativas de una computadora, sino al papel que
ésta desempeña /dentro de cada conexión/, esto es, se designa como
/cliente/ a la computadora que solicita un servicio, y como /servidor/
a la que lo provee; es frecuente que dos computadoras sean tanto
servidor como cliente la una de la otra en distintos servicios.

** Network File System (*nfs*)

El /Sistema de Archivos en Red/ (/Network File System/, mejor conocido
como *nfs*) fue creado por Sun Microsystems, y desde 1984 forma parte
de su sistema operativo —resultó una implementación tan exitosa que a
los pocos años formaba parte de todos los sistemas tipo Unix.

Está construido sobre el mecanismo *rpc* (/remote procedure call/,
/llamada a procedimientos remotos/), un mecanismo de mensajes y manejo
básico de sesión que actúa como una capa superior a *tcp/ip*,
incluyendo facilidades de /descubrimiento de recursos/ y
/abstracción/. *rpc* puede ser comparado con protocolos como *dce/rpc*
de *osf*, *dcom* de Microsoft, y hoy en día, *soap* y *xml-rpc*. Estos
mecanismos permiten al programador delegar en un /servicio/ el manejo
de las conexiones de red, particularmente (en el caso particular aquí
descrito) la persistencia de sesiones en caso de desconexión, y
limitar su atención a una /conexión virtual establecida/.

La motivación de origen para la creación de *nfs* fue presentar una
solución que aprovechara el hardware ya común en dicha época, y que
centralizara la administración: ofrecer las facilidades para contar
con redes donde hubiera un /servidor de archivos/, y donde las
estaciones de trabajo tuvieran únicamente una instalación básica,[fn::
Incluso manejando estaciones de trabajo /diskless/, esto es,
computadoras sin disco duro, cuyo sistema de arranque tiene la
capacidad de solicitar al servidor le envíe incluso el núcleo del
sistema operativo que ejecutará.] y el entorno de usuario completo
estuviera disponible en cualquiera de las estaciones.

El sistema de archivos que ofrece sobre la red *nfs* cumple con la
semántica Unix completa — para emplear un sistema remoto, basta
montarlo[fn:: Para montar un sistema remoto, se emplea un comando como
=mount archivos.unam.mx:/ext/home /home=, con lo cual el directorio
=/ext/home= ubicado en el servidor =archivos.unam.mx= aparecerá
montado como directorio =/home= local.] y usarlo como si fuera
local. El manejo de permisos, usuarios, e incluso las ligas duras y
simbólicas se manejan exactamente como se haría localmente.

El *nfs* viaja sobre un protocolo muy ligero; no implementa cifrado ni
verificaciones adicionales. Al día de hoy, es uno de los mejores
mecanismos para el envío de grandes cantidades de información — pero
siempre en redes que sean /completamente confiables/.

Ahora, *nfs* se presenta como uno de los componentes de una solución
completa. Dado que se espera que la información de usuarios y permisos
sea /consistente/ en todos los clientes; Sun ofrecía también un
esquema llamado /Yellow Pages/ (posteriormente renombrado a *nis*,
/Network Information System/) para compartir la información de
autenticación y listas de usuarios.

La desventaja, en entornos sin *nis*, es que los permisos se manejan
según el identificador numérico del usuario. Si en diferentes sistemas
el mismo usuario tiene distintos identificadores, los permisos no
coincidirán.  Es más, dado que el control de acceso principal es
únicamente por dirección *ip*, para tener acceso irrestricto a los
archivos de otros usuarios en *nfs* basta con tener control pleno de
una computadora cualquiera en la red para poder /asumir o usurpar la
identidad/ de cualquier otro usuario.

Por último, para garantizar que las escrituras a archivos se llevaran
a cabo cuando eran solicitadas (en contraposición a asumir éxito y
continuar), todas las escrituras en un principio sobre *nfs* eran
manejadas de forma /síncrona/, esto es, tras grabar un archivo, el
cliente no continuaba con la ejecución hasta no tener confirmación por
parte del servidor de que los datos estaban ya guardados en
disco. Esto, si bien asegura que el usuario recibirá retroalimentación
confiable respecto a la operación que realizó, ocasiona demoras que
muchas veces son percibidas como excesivas.

Versiones posteriores del protocolo mejoraron sobre los puntos débiles
aquí mencionados. Al día de hoy, casi 30 años después de su
presentación, *nfs* es aún un sistema de archivos en red muy ampliamente
empleado.

** Common Internet File System (*cifs*)

El equivalente a *nfs* en los entornos donde predominan los sistemas
Windows es el protocolo *cifs* (/Common Internet File System/, Sistema
de Archivos Común para Internet). Aparece en los sistemas primarios de
Microsoft alrededor de 1990,[fn:: El desarrollo de *smb* nació como *lan*
Manager, originalmente para *os/2.*] originalmente bajo el nombre *smb*
(/server message block/, /bloque de mensaje del servidor/).

Las primeras implementaciones estaban basadas en el protocolo *nbf*,
frecuentemente conocido como
#+latex: Net\textbf{beui},
#+html: Net<b>beui</b>,
un protocolo no ruteable diseñado para redes pequeñas y entornos
sencillos de oficina. A partir de Windows 2000 se ha reimplementado
completamente para operar sobre *tcp/ip*. Es a partir de este momento
que se le comienza a denominar *cifs*, aunque el nombre *smb* sigue
siendo ampliamente utilizado.[fn:: Es debido a este nombre que la
implementación de *cifs* para sistemas Unix, /Samba/, fue llamado de
esta manera.]

El sistema *cifs* se ajusta mucho más a la semántica de los sistemas
frecuentemente encontrados en las *pc*, *ms-dos* y Windows, aunque
dado el lapso transcurrido desde su introducción y el volumen de
cambios en su mercado objetivo, ha pasado por varios cambios
fundamentales, que al día de hoy complican su uso.

Para tener acceso a un volumen compartido por *smb* se introdujo el
comando =NET=;[fn:: Este comando es empleado en *ms-dos*, pero está
también disponible en Windows, y al día de hoy es una de las
principales herramientas para administrar usuarios.] basta indicar
desde la línea de comando a *dos* o Windows =NET USE W:
\\servidor\directorio= para que el recurso compartido bajo el nombre
=directorio= dentro del equipo conocido como =servidor= aparezca en el
árbol /Mi PC/, y el usuario pueda emplear sus contenidos como si fuera
un sistema de archivos local, con un volumen asignado de =W:=.

Cuando *lan* Manager fue introducido al mercado, los sistemas
Microsoft no manejaban aún el concepto de usuarios, por lo que la
única medida de seguridad que implementaba *smb* era el manejo de
hasta dos contraseñas por directorio compartido: con una, el usuario
obtenía acceso de sólo lectura, y con la otra, de lectura y
escritura. Tras la aparición de Windows *nt*, se agregó un esquema de
identificación por usuario/contraseña, que posibilita el otorgamiento
de permisos con una /granularidad/ mucho menor.[fn:: Esto significa,
que puede controlarse el acceso permitido más finamente, tanto por
archivo como por usuario individual.]

El protocolo empleado por *smb* fue pensado originalmente para una red
/pequeña/, con hasta un par de decenas de equipos. La mayor parte de
los paquetes eran enviados en modo /de difusión/ (/broadcast/), por lo
que era fácil llegar a la saturación, y no había un esquema
centralizado de resolución de nombres, por lo que era frecuente /no
encontrar/ a determinado equipo.

Los cambios que *cifs* presenta a lo largo de los años son muy
profundos. Las primeras implementaciones presentan fuertes problemas
de confiabilidad, rendimiento y seguridad, además de estar planteadas
para su uso en un sólo tipo de sistema operativo; al día de hoy, todos
estos puntos han mejorado fuertemente. En sistemas Unix, la principal
implementación, /Samba/, fue creada haciendo ingeniería inversa sobre
el protocolo; a lo largo de los años, se ha convertido en un esquema
tan robusto que es hoy por hoy tomado como implementación refrencia.

** Sistemas de archivos distribuidos: Andrew File System

# Valdría la pena actualizar esto... Andrew tiene ya sus muchos
# años. ¿Tal vez agregar como ejemplo, o incluso reemplazarlo, con
# esquemas como CEPH, Gluster?

Los dos ejemplos de sistema de archivos en red presentados hasta ahora
comparten una visión /tradicional/ del modelo cliente-servidor: al ver
el comando que inicializa una conexión, e incluso a ver la
información que guarda el núcleo del cliente respecto a cualquiera de
los archivos, resulta claro cuál es el servidor para cada uno de
ellos.

/Andrew File System/, o *afs*, desarrolaldo en la Carnegie Mellon
University[fn:: Como parte del /Proyecto Andrew/, denominado así por
el nombre de los fundadores de esta universidad: Andrew Carnegie y
Andrew Mellon.] y publicado en 1989, plantea presentar un verdadero
/sistema de archivos distribuido/, en el cual los /recursos
compartidos/ no tengan que estar en un servidor en particular, sino
que un conjunto de equipos se repartan la carga (esto es,
/agnosticismo a la ubicación/). *afs* busca también una /fácil
escalabilidad/, la capacidad de agregar tanto espacio de
almacenamiento como equipos con papeles de servidor. *afs* permite
inclusive migrar completamente un volumen mientras está siendo
empleado de forma transparente.

Ante la complejidad e inestabilidad adicional que presentan con
tanta frecuencia las redes grandes[fn:: El uso típico de *afs* se
planteaba para organizaciones grandes, del orden de decenas de miles
de estaciones.] (y lo hacían mucho más hace 30 años): *afs* debe operar
tan confiablemente como sea posible, /incluso sin la certeza de que la
red opera correctamente/.

La autenticación en *afs* se basa fuertemente sobre el modelo de
/tickets/ y credenciales de /Kerberos/,[fn:: Un sistema de
autenticación y autorización centralizado para entornos corporativos.]
pero se aleja sensiblemente de la semántica de operación de archivos
que hasta ahora se han presentado. Muchos eventos, operaciones y
estados van ligados al /momento en el tiempo/ en que se presentan,
mediante un /modelo de consistencia débil/ (/weak consistency
model/). Muy a grandes rasgos, esto significa que:

- Cuando se abre un archivo, éste se copia completo al cliente. Todas
  las lecturas /y escrituras/ (a diferencia de los esquemas
  tradicionales, en que éstas son enviadas al servidor /lo antes
  posible/ y de forma síncrona) se dirigen únicamente a la copia
  local.

- Al cerrar el archivo, éste se copia de vuelta al /servidor de
  origen/, el cual se /compromete/ a notificar a los clientes si un
  archivo abierto fue modificado (esto es, a /hacer una llamada/ o
  /callback/). Los clientes pueden entonces intentar incorporar los
  cambios a su versión de trabajo, o continuar con la copia ya
  obtenida —es /de esperarse/ que si un segundo cliente realiza alguna
  modificación, incorpore los cambios hechos por el primero, pero esta
  responsabilidad se deja a la implementación del programa en
  cuestión.

Esto significa en pocas palabras que los cambios a un archivo abierto
por un usuario no son visibles a los demás de inmediato; sólo una vez
que se cierra un archivo, los cambios hechos a éste son puestos a
disposición de las sesiones abiertas actuales, y sólo son enviados
como /versión actual/ a las sesiones abiertas posteriormente.

Con este cambio semántico, debe quedar claro que *afs* no busca ser un
sistema para todo uso ni un reemplazo universal de los sistemas de
archivos locales, en contraposición de los sistemas de archivos
centralizados. *afs* no plantea en ningún momento una operación
/diskless/. Bajo el esquema aquí descrito, las lecturas y escrituras
resultan baratas, porque se realizan exclusivamente sobre el caché
local, pero abrir y cerrar un archivo puede ser muy caro, porque debe
transferirse el archivo completo.

Hay aplicaciones que verdaderamente sufrirían si
tuvieran que implementarse sobre un sistema de archivos distribuido,
por ejemplo, si una base de datos se distribuyera sobre *afs*, la
carencia de mecanismos de bloqueo sobre /secciones/ del archivo, y el
requisito de operar sobre /archivos completos/ harían impracticable
compartir un archivo de uso intensivo y aleatorio.

* Ejercicios

** Preguntas de autoevaluación

1. Identifique diferentes sistemas de cómputo (computadoras,
   teléfonos, dispositivos móviles, dispositivos de función específica
   como cámaras digitales o reproductores de medios, etc.) a los que
   tiene acceso. ¿Cómo identifica cada uno de ellos el tipo de
   archivos? ¿Implementan alguna abstracción ocultando o traduciendo
   la presentación de determinados archivos de forma transparente al
   usuario?

2. Hay diferentes modos en que un programa puede accesar a la
   información contenida en un archivo; siendo los principales
   /secuencial/, /aleatorio/ y /relativo a índice/. Indique qué casos
   de uso resuelve mejor cada uno de estos modos de acceso.

3. ¿Qué tipo de optimización podría llevar a cabo el sistema operativo
   si requiriera que todo programa declarara al momento de abrir un
   archivo si va a utilizarlo de forma mayormente secuencial o
   aleatoria?

4. De las siguientes afirmaciones, identifique cuáles se refieren a
   /ligas duras/, a /ligas simbólicas/, y a /enlaces directos/. Hay
   una sóla respuesta correcta para cada afirmación.

   1. Son dos (o más) entradas en el directorio apuntando al mismo
      \mbox{i-nodo}.
   2. Es un archivo normal e independiente en el sistema de archivos,
      que podría ser abierto directamente por los programas.
   3. Pueden apuntar a directorios, incluso creando ciclos.
   4. Su tipo de archivo en el directorio está indicado por la
      extensión =.LNK=.
   5. El sistema operativo /resuelve directamente/ todas las
      operaciones /como si fueran/ al archivo referido.
   6. No pueden referirse a archivos en sistemas de archivos distintos
      del propio.
   7. Pueden formar representarse en un sistema de archivos tipo *fat*.
   8. Si un usuario elimina cualquiera de las referencias a un archivo
      empleando este esquema, el archivo sigue existiendo en las demás.

5. Cuando se habla acerca de los sistemas de archivos remotos o en
   red, ¿qué significa la /semántica de manejo de errores/? Presente
   un ejemplo de cómo se refleja una distinta semántica entre un
   sistema de archivos local y uno en red.

6. Suponga que hay un archivo =file0= en un sistema de archivos con
   semántica tipo Unix. Explique qué ocurre en cada situación (con su
   inodo, con sus sectores de contenido, entradas de directorio,
   etcétera):

   - Copiado: =cp file0 file1=
   - Liga dura: =ln file0 file1=
   - Liga simbólica: =ln -s file0 file1=
   - Eliminación: =rm file0=

7. La estructura i-nodo tiene, en casi todos los sistemas de archivos,
   un campo de /conteo de ligas/. Explique qué es. ¿Qué operaciones
   llevan a que se modifique, qué ocurre si llega a cero?

** Temas de investigación sugeridos
- Sistemas de archivos distribuidos ::

  En este capítulo se abordaron tres sistemas de archivos /remotos/,
  de los cuales sólo el último puede verse como un sistema de archivos
  /distribuido/: bajo *afs*, los datos almacenados no están en una única
  computadora. Pero *afs* tiene ya muchos años de haber sido
  desarrollado, por lo cual su diseño no consideró muchos de los
  aspectos de las redes de datos globales actuales.

  En los últimos años se han presentado varias propuestas de sistemas
  de archivos verdaderamente distribuidos, aptos para la
  implementación de /nubes/ de datos y de una distribución geográfica
  de la información; algunos ejemplos de estos sistemas de archivos
  son GlusterFS (desarrollado por RedHat), S3 (de Amazon), GoogleFS
  (de Google), Windows Distributed File System (de Microsoft), y *ceph*
  (también de RedHat).

  ¿Qué semántica ofrecen estos sistemas de archivos, cómo se comparan
  con la nativa de las diferentes plataformas, cómo se opera en caso
  de desconexión o falla, parcial o total, qué características hacen a
  estos sistemas /especialmente/ buenos para su uso distribuido,
  habría alguna desventaja de emplear esos sistemas en un entorno de
  red local?

** Lecturas relacionadas
- \fullcite{FileSystemInterfaceGNUlibc}
- \fullcite{McKusick2012}
  - Traducción al español: \fullcite{CesarYanez2013}
- \fullcite{Heidemann1994}
- \fullcite{Anderson1996}
- \fullcite{Walberg2006}

# Liga rota :-(
# - /OpenPlanets Results Evaluation Framework/
#   #+latex: \otrorec{http://data.openplanetsfoundation.org/ref/}
#   #+html: <br/><a href="http://data.openplanetsfoundation.org/ref/">http://data.openplanetsfoundation.org/ref/</a><br/>
#   David Tarrant
#   (2012). Muestra la evolución a lo largo de los años de cómo
#   reconocen archivos de tipos conocidos varias herramientas

