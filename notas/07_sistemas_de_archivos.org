#+SETUPFILE: ../setup_notas.org
#+TITLE: Sistemas de archivos

* Plasmando la estructura en el dispositivo
# <<FS>>

A lo largo del capítulo \ref{DIR} se abordaron los elementos del sistema de archivos tal
como son presentados al usuario final, sin entrar en detalles respecto
a cómo organiza toda esta información el sistema operativo en un
/dispositivo persistente/ —mencionamos algunas estructuras base, pero
dejándolas explícitamente pendientes de definición. En este capítulo
se tratarán las principales estructuras y mecanismos
empleados para que un sistema de archivos sea ya no sólamente una
estructura formal ideal, sino que una entidad almacenada en un dispositivo.

A lo largo de la historia del cómputo, el almacenamiento no siempre se
realizó en discos (dispositivos giratorios de acceso aleatorio). Por
varias décadas, los medios principales almacenamiento eran de acceso
estrictamente secuencial (tarjetas perforadas, cintas de papel, cintas
magnéticas); por más de 30 años, el medio primario de almacenamiento
han sido los distintos tipos de discos magnéticos, y desde hace
algunos años, estamos viendo una migración a /almacenamiento de estado
sólido/, a dispositivos sin partes móviles que guardan la información
en un tipo particular de memoria (tema que se abordará en la sección
\ref{FS_FIS_estado_solido}). Volviendo a las categorías presentadas en
la sección \ref{HW_refiriendo}, los medios de acceso secuencial son
/dispositivos de caracteres/, y tanto discos como unidades de estado
sólido son /dispositivos de bloques/.

** Conceptos para la organización
# <<FS_conceptos>>

Los sistemas de archivo están en general desarrollados pensando en
/discos/, y a lo largo de este capítulo, se hará referencia como /el
disco/ al medio de almacenamiento persistente en el cual esté plasmado
el sistema de archivos. En el apéndice \ref{FS_FIS} se tocarán algunos
de los aspectos que debemos considerar al hablar de sistemas de
archivos respaldados en medios /distintos/ a un disco.

Mientras tanto, conviene mantener una visión aún bastante idealizada y
abstracta: un /disco/ visto desde la perspectiva del sistema operativo
será presentado a lo largo del presente capítulo[fn:: Para un punto de
vista más riguroso de cómo se relaciona el sistema operativo con los
discos y demás mecanismos de almacenamiento, refiérase al apéndice
\ref{FS_FIS}.] como un arreglo muy grande de /bloques/ de tamaño fijo,
cada uno de ellos /directamente direccionable/; esto significa que el
sistema operativo puede referirse por igual a cualquiera de los
bloques del disco mediante una dirección física e inambigua dentro del
disco entero. Partiendo de esto, se emplean los siguientes conceptos
para almacenar, ubicar o recuperar la información:

- Partición :: Una subdivisión de un disco, por medio de la cual el
               administrador o usuario del sistema puede definir la
               forma en que se emplea el espacio del disco,
               segmentándolo según haga falta.

	       Un disco puede tener varias particiones, y cada una de
               ellas puede tener un sistema de archivos independiente.

- Volumen :: Colección de bloques /inicializados/ con un sistema de
             archivos que pueden presentarse al usuario como una
             unidad. Típicamente un volumen coincide con una partición
             (pero no siempre es el caso, como se describirá en las
             secciones \ref{FS_FIS_RAID} y \ref{FS_FIS_man_av_vol}).

	     El volumen se /describe/ ante el sistema operativo en el
             /bloque de control de volumen/, también conocido como
             /superbloque/ en Unix, o /tabla maestra de archivos/
             (/master file table/) en *ntfs*.

- Sistema de archivos :: Esquema de organización que sigue un
     determinado /volumen/. Dependiendo del sistema de archivos
     elegido, cada uno de los componentes aquí presentados ocuparán un
     distinto lugar en el disco, presentando una semántica
     propia.

     Para poder tener acceso a la información almacenada en
     determinado volumen, el sistema operativo debe tener soporte para
     el sistema de archivos particular en que éste esté estructurado.

- Directorio raíz :: La estructura que relaciona cada nombre
     de archivo con su números de /i-nodo/. Típicamente sólo almacena los
     archivos que están en el /primer nivel jerárquico/ del sistema, y
     los directorios derivados son únicamente referenciados desde
     éste.

     En sistemas de archivos modernos, el directorio normalmente
     incluye sólo el nombre de cada uno de
     los archivos y el número de /i-nodo/ que lo describe, todos los
     /metadatos/ adicionales están en los respectivos /i-nodos/.

- Metadatos :: Recibe este nombre toda la información /acerca de/ un
               archivo que /no es/ el contenido del archivo mismo. Por ejemplo, el
               nombre, tamaño o tipo del archivo, su propietario, el
               control de acceso, sus fechas de creación, último
               acceso y modificación, ubicación en disco, etcétera.

- /I-nodo/ :: Del inglés /i-node/, /information node/ (nodo de
              información); en los sistemas tipo Windows, normalmente
              se le denomina /bloque de control de archivo/
              (*fcb*). Es la estructura en disco que guarda los
              /metadatos/ de cada uno de los archivos, proporcionando
              un vínculo entre la /entrada en el directorio/ y los
              datos que lo conforman.

	      La información almacenada incluye todos los metadatos
              relacionados con el archivo /a excepción del nombre/
              (mismo que radica únicamente en el /directorio/): los
              permisos y propietarios del archivo, sus fechas de
              creación, última modificación y último acceso, y la
              /relación de bloques/ que ocupa en el disco. Más
              adelante se abordarán algunos de los esquemas más
              comunes para presentar esta relación de bloques.

	      Esta separación entre directorio e /i-nodo/ permite a un
              mismo archivo formar parte de distintos directorios,
              como se explicó en la sección \ref{DIR_grafo_dirigido}.

- /Mapa de bits/ de espacio libre :: La función del bitmap es poder gestionar
     el espacio libre del disco. Recuérdese que el disco se presenta
     asignado por /bloques/, típicamente de $4~096$ bytes — en el bitmap
     cada bloque se representa con un bit, con lo que aquí se puede
     encontrar de forma compacta el espacio ocupado y disponible, así
     como el lugar adecuado para crear un nuevo archivo.

     El bitmap para un disco de 100 *gb*, de esta manera, se puede
     representar en 23 *mb* ($100 \times 10^9 \over 4~096$), cantidad
     que puede razonablemente mantener en memoria un sistema de
     escritorio promedio hoy en día.[fn:: Esto explica porqué,
     incluso sin estar trabajando activamente con ningún archivo
     contenido en éste, el solo hecho de montar un volumen con gran
     cantidad de datos obliga al sistema a reservarle una cantidad de
     memoria.]

     Más adelante se verán algunas estructuras avanzadas que permiten
     mayor eficiencia en este sentido.

** Diferentes sistemas de archivos

Un sistema operativo puede dar soporte a varios distintos sistemas de
archivos; un administrador de sistemas puede tener muy diferentes
razones que influyan para elegir cuál sistema de archivos empleará
para su información; algunas razones para elegir a uno u otro son que
el rendimiento de cada uno puede estar /afinado/ para diferentes
patrones de carga, necesidad de emplear un dispositivo portátil para
intercambiar datos con distintos sistemas, e incluso restricciones de
hardware.[fn:: Por ejemplo, los /cargadores de arranque/ en algunas
plataformas requieren poder leer el volumen donde está alojada la
imágen del sistema operativo —lo cual obliga a que esté en un sistema
de archivos nativo a la plataforma.]

A lo largo de esta sección se revisará cómo los principales
conceptos a abordar se han implementado en distintos sistemas de
archivos; se hará referencia principalmente a una familia de sistema de
archivos simple de comprender, aunque muestra claramente su edad: el
sistema *fat*. La razón para elegir al sistema de archivos *fat* es la
simplicidad de sus estructuras, que permiten comprender la
organización general de la información. Donde sea pertinente, se
mencionará en qué puntos principales estiba la diferencia con los
principales sistemas de la actualidad.

El sistema *fat* fue creado hacia finales de los setenta, y su diseño
muestra claras evidencias de haber sido concebido para discos
flexibles. Sin embargo, por medio de varias extensiones que se han
presentado con el paso de los años (algunas con compatibilidad hacia
atrás,[fn:: Se denomina /compatibilidad hacia atrás/ a aquellos
cambios que permiten interoperar de forma transparente con las
versiones anteriores.] otras no), sigue siendo uno de los sistemas más
empleados al día de hoy, a pesar de que ya no es recomendado como
sistema primario por ningún sistema operativo de escritorio.

Si bien *fat* tuvo su mayor difusión con los sistemas operativos de la
familia *ms-dos*, es un sistema de archivos nativo para una gran
cantidad de otras plataformas (muchas de ellas dentro del mercado
/embebido/), lo cual se hace obvio al revisar el soporte a atributos
extendidos que maneja.

** El volumen

Lo primero que requiere saber el sistema operativo para poder montar
un volumen es su estructura general: en primer término, de qué /tipo/
de sistema de archivos se trata, y acto seguido, la descripción básica
del mismo: su extensión, el tamaño de los /bloques lógicos/ que
maneja, si tiene alguna /etiqueta/ que describa su función ante el
usuario, etc. Esta información está contenida en el /bloque de control
de volumen/, también conocido como /superbloque/ o /tabla maestra de
archivos/.[fn:: Y aquí hay que aclarar: este bloque /no contiene a
los archivos/, ni siquiera a las estructuras que apuntan hacia ellos,
sólo describe al volumen para que pueda ser montado.]

Tras leer la información del superbloque, el sistema operativo
determina en primer término si puede proceder — si no sabe cómo
trabajar con el sistema de archivos en cuestión, por ejemplo, no
puede presentar información útil alguna al usuario (e incluso
arriesgaría destruirla).

Se mencionó ya que el tamaño de bloques (históricamente, 512 bytes; el
estándar /Advanced Format/ en marzo del 2010 introdujo bloques de
$4~096$ bytes) es establecido por el hardware. Es muy común que, tanto
por razones de eficiencia como para alcanzar a direccionar mayor
espacio, el sistema de archivos /agrupe/ a varios bloques físicos en
uno lógico. En la sección \ref{FS_el_directorio} se revisará qué
factores determinan el tamaño de bloques en cada sistema de archivos.

Dado que describir el volumen es la más fundamental de las operaciones
a realizar, muchos sistemas de archivos mantienen /copias adicionales/
del superbloque, a veces dispersas a lo largo del sistema de archivos,
para poder recuperarlo en caso de que se corrompa.

En el caso de *fat*, el volumen indica no sólo la /generación/ del
sistema de archivos que se está empleando (*fat12*, *fat16* o *fat32*, en
los tres casos denominados así por la cantidad de bits para
referenciar a cada uno de los bloques lógicos o /clusters/), sino el
tamaño de los /clusters/, que puede ir desde los dos y hasta los 32 *kb*.

*** Volúmenes /crudos/
# <<FS_volumenes_crudos>>

Si bien una de las principales tareas de un sistema operativo es la
organización del espacio de almacenamiento en sistemas de archivos y
su gestión para compartirse entre diversos usuarios y procesos, hay
algunos casos en que un dispositivo orientado a bloques puede ser
puesto a disposición de un proceso en particular para que éste lo
gestione directamente. Este modo de uso se denomina /dispositivos
crudos/ o /dispositivos en crudo/ (/raw devices/).

Pueden encontrarse dos casos de uso primarios hoy en día para
dispositivos orientados a bloques no administrados mediante la
abstracción de los sistemas de archivos:

- Espacio de intercambio :: Como se vio en la sección \ref{MEM_acomodo_de_paginas}, la
     gestión de la porción de la memoria virtual que está en disco es
     mucho más eficiente cuando se hace sin cruzar por la abstracción
     del sistema operativo — esto es, cuando se hace en un volumen en
     crudo. Y si bien el gestor de memoria virtual es parte innegable
     del sistema operativo, en un sistema /microkernel/ puede estar
     ejecutándose como proceso de usuario.

- Bases de datos :: Las bases de datos relacionales pueden incluir
                    volúmenes muy grandes de datos estrictamente
                    estructurados. Algunos gestores de bases de
                    datos, como Oracle,
		    #+latex: Max\textbf{db}
		    #+html: Max<b>db</b>
		    o *db2*, recomiendan a sus usuarios el uso de
                    volúmenes crudos, para optimizar los accesos a
                    disco sin tener que cruzar por tantas capas del
                    sistema operativo.

		    La mayor parte de los gestores de bases de datos
                    desde hace varios años no manejan esta modalidad,
                    por la complejidad adicional que
                    supone para el administrador del sistema y por lo
                    limitado de la ventaja en rendimiento que supone
                    hoy en día, aunque es indudablemente un tema que
                    se presta para discusión e investigación.

** El directorio y los /i-nodos/
# <<FS_el_directorio>>

El directorio es la estructura que relaciona a los archivos como son
presentados al usuario –identificados por una ruta y un nombre– con
las estructuras que los describen ante el sistema operativo — los
/i-nodos/.

A lo largo de la historia de los sistemas de archivos, se han
implementado muy distintos esquemas de organización. Se presenta a
continuación la estructura básica de la popular familia de sistemas de
archivos *fat*.

*** El directorio raíz

Una vez que el sistema de archivos está /montado/ (véase
\ref{DIR_montaje_directorios}), todas las referencias a archivos
dentro de éste deben pasar a través del directorio. El directorio raíz
está siempre en una ubicación /bien conocida/ dentro del sistema de
archivos — típicamente al inicio del volumen, en los primeros
sectores.[fn:: Una excepción a esta lógica se presentó en la década de
los 1980, cuando los diseñadores del sistema
#+latex: Amiga\textbf{os},
#+html: Amiga<b>os</b>,
decidieron ubicar al directorio en el sector /central/ de los
volúmenes, para reducir a la mitad el tiempo promedio de acceso a la
parte más frecuentemente referida del disco.] Un disco flexible tenía
80 /pistas/ (típicamente denominadas /cilindros/ al hablar de discos
duros), con lo que, al ubicar al directorio en la pista 40, el tiempo
promedio de movimiento de cabezas para llegar a él se reducía a la
mitad. Si todas las operaciones de abrir un archivo tienen que pasar
por el directorio, esto resultaba en una mejoría muy significativa.

El directorio es la estructura que determina el formato que debe
seguir el nombre de cada uno de los archivos y directorios: es común
que en un sistema moderno, el nombre de un archivo pueda tener hasta
256 caracteres, incluyendo espacios, caracteres internacionales, etc. Algunos
sistemas de archivos son /sensibles a mayúsculas/, como es el caso de
los sistemas nativos a Unix (el archivo =ejemplo.txt= es distinto de
=Ejemplo.TXT=), mientras que otros no lo son, como es el caso de *ntfs*
y *vfat* (=ejemplo.txt= y =Ejemplo.TXT= son idénticos ante el sistema
operativo).

Todas las versiones de *fat* siguen para los nombres de archivos un
esquema claramente arcaico: los nombres de archivo pueden medir hasta
ocho caracteres, con una extensión opcional de tres caracteres más,
dando un total de 11. El sistema no sólo no es sensible a mayúsculas y
minúsculas, sino que todos los nombres deben guardarse completamente
en mayúsculas, y permite sólo ciertos caracteres no
alfanuméricos. Este sistema de archivos no implementa la separación
entre directorio e i-nodo, que hoy es la norma, por lo que cada una de
las entradas en el directorio mide exactamente 32 bytes. Como es de
esperarse en un formato que ha vivido tanto tiempo y ha pasado por
tantas generaciones como *fat*, algunos de estos campos han cambiado
sustancialmente sus significados. La figura
\ref{FS_entrada_directorio_fat} muestra los campos de una entrada del
directorio bajo *fat32*.

#+attr_latex: width=\textwidth
#+label: FS_entrada_directorio_fat
#+caption: Formato de la entrada del directorio bajo *fat* (Mohammed, 2007).
[[./img/ditaa/entrada_directorio_fat.png]]

#+latex: \eject
La extensión *vfat* fue agregada con el lanzamiento de Windows 95. Esta
extensión permitía que, si bien el nombre /real/ de un archivo
seguiría estando limitada al formato presentado, pudieran agregarse
entradas adicionales al directorio utilizando el atributo de /etiqueta
de volumen/ de maneras que un sistema *ms-dos* debiera ignorar.[fn:: La
/etiqueta de volumen/ estaba definida para ser empleada exclusivamente
/a la cabeza/ del directorio, dando una etiqueta global al sistema de
archivos completo; el significado de una entrada de directorio con
este atributo hasta antes de la incorporación de *vfat* /no estaba
definida/.]

Esto presenta una complicación adicional al hablar del directorio
/raíz/ de una unidad: si bien los directorios derivados no tienen este
límite, al estar el directorio raíz ubicado en una sección fija del
disco, tiene una longitud límite máxima: en un disco flexible (que
hasta el día de hoy, por su baja capacidad, se formatea bajo *fat12*),
desde el bloque 20 y hasta el 33, esto es, 14 bloques. Con un tamaño
de sector de 512 bytes, el directorio raíz mide $512 \times 14 = 7~168$
bytes, esto es $\frac{7~168}{32} = 224$ entradas como máximo. Y si
bien esto puede no parecer muy limitado, ocupar cuatro entradas por
archivo cuando, empleando *vfat*, se tiene un nombre medianamente
largo reduce fuertemente el panorama.

El problema no resulta tan severo como podría parecer: para *fat32*, el
directorio raíz ya no está ubicado en un espacio reservado, sino que
como parte del espacio de datos, por lo cual es extensible en caso de
requerirse.

#+label: FS_directorio_vfat
#+caption: Entradas representando archivos con (y sin) nombre largo bajo *vfat*.
#+attr_html: width="843" height="724"
#+attr_latex: width=\textwidth
[[./img/directorio_vfat.png]]

Los primeros sistemas de archivos estaban pensados para unidades de
muy baja capacidad; por mucho tiempo, las implementaciones del
directorio eran simplemente listas lineales con los archivos que
estaban alojados en el volumen. En muchos de estos primeros sistemas
no se consideraban directorios jerárquicos, sino que presentaban un
único espacio /plano/ de nombres; cuando estos sistemas fueron
evolucionando para soportar directorios anidados, por compatibilidad
hacia atrás (y por consideraciones de rendimiento que se abordan a
continuación) siguieron almacenando únicamente al directorio raíz en
esta posición privilegiada, manejando a todos los directorios que
derivaran de éste como si fueran archivos, repartidos por el disco.

#+caption: Significado de cada uno de los bits del byte de /atributos del archivo/ en el directorio *fat*. La semántica que se presenta es la empleada por los sistemas *ms-dos* y Windows; otros sistemas pueden presentar comportamientos adicionales.
#+label: FS_atributos_fat
| Bit | Nombre        | Descripción                                  |
|-----+---------------+----------------------------------------------|
|   0 | Sólo lectura  | El sistema no permitirá que sea modificado.  |
|   1 | Oculto        | No se muestra en listados de directorio.     |
|   2 | Sistema       | El archivo pertenece al sistema y no debe    |
|     |               | moverse de sus /clusters/ (empleado, por     |
|     |               | ejemplo, para los componentes a cargar para  |
|     |               | iniciar al sistema operativo).               |
|   3 | Etiqueta      | Indica el nombre del volumen, no un archivo. |
|     |               | En *vfat*, expresa la /continuación/ de un   |
|     |               | nombre largo.                                |
|   4 | Subdirectorio | Los /clusters/ que componen a este archivo   |
|     |               | son interpretados como un subdirectorio,     |
|     |               | no como un archivo.                          |
|   5 | Archivado     | Empleado por algunos sistemas de respaldo    |
|     |               | para indicar si un archivo fue modificado    |
|     |               | desde su última copia.                       |
|   6 | Dispositivo   | Para uso interno del sistema operativo, no   |
|     |               | fue adoptado para los archivos.              |
|   7 | Reservado     | Reservado, no debe ser manipulado.           |
|-----+---------------+----------------------------------------------|

En un sistema que implementa los directorios como listas lineales,
entre más archivos haya, el tiempo que toma casi cualquier operación
se incrementa linealmente (dado que potencialmente se tiene que leer
el directorio completo para encontrar un archivo). Y las listas
lineales presentan un segundo problema: cómo reaccionar cuando se
/llena/ el espacio que tienen asignado.

Como ya se presentó, *fat* asigna un espacio fijo al directorio raíz,
pero los subdirectorios pueden crecer abritrariamente. Un
subdirectorio es básicamente una entrada con un tipo especial de
archivo —si el doceavo byte de una entrada de directorio, que indica
los /atributos del archivo/ (véase la figura
\ref{FS_entrada_directorio_fat} y el cuadro \ref{FS_atributos_fat}) tiene
al bit cuatro activado, la región de datos correspondientes a dicho archivo
será interpretada como un subdirectorio.

*** La tabla de asignación de archivos
# <<FS_tabla_fat>>

Queda claro que *fat* es un sistema heredado, y que exhibe muchas
prácticas que ya se han abandonado en diseños modernos de sistemas de
archivos. Se vio que dentro de la entrada de directorio de cada archivo
está prácticamente su /i-nodo/ completo: la información de permisos,
atributos, fechas de creación, y muy particularmente, el apuntador
al /cluster/ de inicio (bytes 26-28, más los 20-22 para *fat32*). Esto
resulta en una de las grandes debilidades de *fat*: la tendencia a la
fragmentación.

La familia *fat* obtiene su nombre de la tabla de asignación de
archivos (/file allocation table/), que aparece antes del directorio,
en los primeros sectores del disco.[fn:: Esta tabla es tan importante
que, dependiendo de la versión de *fat*, se guarda por duplicado, o
incluso por triplicado.] Cada byte de la *fat* representa un /cluster/
en el área de datos; cada entrada en el directorio indica, en su campo
correspondiente, cuál es el primer /cluster/ del archivo. Ahora
bien, conforme se usa un disco, y los archivos crecen y se eliminan, y
van llenando los espacios vacíos que van dejando, *fat* va asignando
espacio /conforme encuentra nuevos clusters libres/, sin cuidar que
sea espacio continuo. Los apuntadores al /siguiente cluster/ se van
marcando en la tabla, /cluster/ por /cluster/, y el último de cada
archivo recibe el valor especial (dependiendo de la versión de *fat*)
=0xFFF=, =0xFFFF= o =0xFFFFFFFF=.

Ahora bien, si los directorios son sencillamente archivos que reciben
un tratamiento especial, éstos son también susceptibles a la
fragmentación. Dentro de un sistema Windows 95 o superior (empleando
las extensiones *vfat*), con directorios anidados a cuatro o cinco
niveles como lo establece su jerarquía estándar,[fn:: Por ejemplo,
=C:\Documents and Settings\Usuario\Menú Inicio\Programa
Ejemplo\Programa Ejemplo.lnk=] la simple tarea de recorrerlos para
encontrar determinado archivo puede resultar muy penalizado por la
fragmentación.

*** La eliminación de entradas del directorio

Sólo unos pocos sistemas de archivos guardan sus directorios ordenados
— si bien esto facilitaría las operaciones más frecuentes que se
realizan sobre ellos (en particular, la búsqueda: cada vez que un
directorio es recorrido hasta encontrar un archivo tiene que leerse
potencialmente completo), mantenerlo ordenado ante cualquier
modificación resultaría mucho más /caro/, dado que tendría que
reescribirse el directorio completo al crearse o eliminarse un archivo
dentro de éste, y lo que es más importante, más /peligroso/, dado que
aumentaría el tiempo que los datos del directorio están en un estado
inconsistente, aumentando la probabilidad de que ante una interrupción
repentina (fallo de sistema, corte eléctrico, desconexión del
dispositivo, etc.) se presentara corrupción de la información llevando
a pérdida de datos. Al almacenar las entradas del directorio sin
ordenar, las escrituras que modifican esta crítica estructura se
mantienen atómicas: un solo sector de 512 bytes puede almacenar 16
entradas básicas de *fat*, de 32 bytes cada una.[fn:: Aunque en el
caso de *vfat*, las diferentes entradas que componen un sólo nombre de
archivo pueden quedar separadas en diferentes sectores.]

Ordenar las entradas del directorio teniendo sus contenidos ya en
memoria y, en general, diferir las modificaciones al directorio
resulta mucho más conveniente en el caso general. Esto vale también
para la eliminación de archivos —a continuación se abordará la
estrategia que sigue *fat*. Cabe recordar que *fat* fue diseñado cuando el
medio principal de almacenamiento era el disco flexible, decenas de
veces más lento que el disco duro, y con mucha menor confiabilidad.

Cuando se le solicita a un sistema de archivos *fat* eliminar un
archivo, éste no se borra del directorio, ni su información se libera
de la tabla de asignación de archivos, sino que se /marca/ para ser
ignorado, reemplazando el primer caracter de su nombre por =0xE5=. Ni
la entrada de directorio, ni la /cadena/ de /clusters/ correspondiente
en las tablas de asignación,[fn:: Este tema será abordado en breve, en
la sección \ref{FS_tablas_fat}, al hablar de las tablas de asignación
de archivos.] son eliminadas —sólo son marcadas como
/disponibles/. El espacio de almacenamiento que el archivo eliminado
ocupa debe, entonces, ser /sumado/ al espacio libre que tiene el
volumen. Es sólo cuando se crea un nuevo archivo empleando esa misma
entrada, o cuando otro archivo ocupa el espacio físico que ocupaba el
que fue eliminado, que el sistema operativo marca /realmente/ como
desocupados los /clusters/ en la tabla de asignación.

Es por esto por lo que desde los primeros días de las *pc* hay tantas
herramientas de recuperación (o /des-borramiento/, /undeletion/) de
archivos: siempre que no haya sido creado uno nuevo que ocupe la
entrada de directorio en cuestión, recuperar un archivo es tan simple
como volver a ponerle el primer caracter a su nombre.

Este es un ejemplo de un /mecanismo flojo/ (en contraposición de los
/mecanismos ansiosos/, como los vistos en la sección
\ref{MEM_pag_sobre_demanda}). Eliminar un archivo requiere de un
trabajo mínimo, mismo que es /diferido/ al momento de reutilización de
la entrada de directorio.

** Compresión y /desduplicación/
# <<FS_compr_dedup>>

Los archivos almacenados en un área dada del disco tienden a presentar
patrones comunes. Algunas situaciones ejemplo que llevarían a estos
patrones comunes son:

- Dentro del directorio de trabajo de cada uno de los usuarios hay
  típicamente archivos creados con los mismos programas, compartiendo
  encabezado, estructura, y ocasionalmente incluso parte importante
  de los datos.
- Dentro de los directorios de binarios del sistema,
  habrá muchos archivos ejecutables compartiendo el mismo /formato
  binario/.
- Es muy común también que un usuario almacene versiones distintas del
  mismo documento.
- Dentro de un mismo documento, es frecuente que el autor repita en
  numerosas ocasiones las palabras que describen sus conceptos
  principales.

Conforme las computadoras aumentaron su poder de cómputo, desde
finales de los ochenta se presentaron varios mecanismos que permitían
aprovechar las regularidades en los datos almacenados en el disco para
comprimir el espacio utilizable en un mismo medio. La compresión
típicamente se hace por medio de mecanismos estimativos derivados del
análisis del contenido,[fn:: Uno de los algoritmos más frecuentemente
utilizados y fáciles de entender es la /Codificación Huffman/; éste y
la familia de algoritmos /Lempel-Ziv/ sirven de base para
prácticamente la totalidad de las implementaciones.] que tienen como
resultado un nivel variable de compresión: con tipos de contenido
altamente regulares (como podría ser texto, código fuente, o audio e
imágenes /en crudo/), un volumen puede almacenar frecuentemente mucho
más de 200% de su espacio real.

Con contenido poco predecible o con muy baja redundancia (como la
mayor parte de formatos de imágenes y audio, que incluyen ya una fase
de compresión, o empleando cualquier esquema de cifrado) la compresión
no ayuda, y sí reduce el rendimiento global del sistema en que es
empleada.

*** Compresión de volumen completo

El primer sistema de archivos que se popularizó fue /Stacker/,
comercializado a partir de 1990 por /Stac Electronics/. /Stacker/
operaba bajo *ms-dos*, creando un dispositivo de bloques virtual alojado
en un disco estándar.[fn:: Esto significa que, al solicitarle la
creación de una unidad comprimida de 30 *mb* dentro del volumen =C=
(disco duro primario), ésta aparecería disponible como un volumen
adicional. El nuevo volumen requería de la carga de un /controlador/
especial para ser /montado/ por el sistema operativo.] Varias
implementaciones posteriores de esta misma época se basaron en este
mismo principio.

Ahora, sumando la variabilidad derivada del enfoque probabilístico al
uso del espacio con el ubicarse como una compresión orientada al
volumen entero, resulta natural encontrar una de las dificultades
resultantes del uso de estas herramientas: dado que el sistema
operativo estructura las operaciones de lectura y escritura por
bloques de dimensiones regulares (por ejemplo, el tamaño típico de
sector hardware de 512 bytes), al poder éstos traducirse a más o menos
bloques reales tras pasar por una capa de compresión, es posible que
el sistema de archivos tenga que reacomodar constantemente la
información al /crecer/ alguno de los bloques previos.  Conforme mayor
era el tiempo de uso de una unidad comprimida por /Stacker/, se notaba
más degradación en su rendimiento.

Además, dado que bajo este esquema se empleaba el sistema de archivos
estándar, las tablas de directorio y asignación de espacio resultaban
también comprimidas. Estas tablas, como ya se ha expuesto, contienen
la información fundamental del sistema de archivos; al comprimirlas y
reescribirlas constantemente, la probabilidad de que resulten dañadas
en alguna falla (eléctrica o lógica) aumenta. Y si bien los discos
comprimidos por /Stacker/ y otras herramientas fueron populares,
principalmente durante la primera mitad de los noventa, conforme
aumentó la capacidad de los discos duros fue declinando su
utilización.

*** Compresión archivo por archivo

Dado el éxito del que gozó /Stacker/ en sus primeros años, Microsoft
anunció como parte de las características de la versión 6.0 de *ms-dos*
(publicada en 1993) que incluiría /DoubleSpace/, una tecnología muy
similar a la de /Stacker/. Microsoft incluyó en sus sistemas operativos
el soporte para DoubleSpace
por siete años, cubriendo las últimas versiones de *ms-dos* y las de
Windows 95, 98 y Millenium, pero como ya se vio, la compresión de
volumen completo presentaba importantes desventajas.

Para el entonces nuevo sistemas de archivos *ntfs*, Microsoft decidió
incluir una característica distinta, más segura y más modular:
mantener el sistema de archivos funcionando de forma normal, sin
compresión, y habilitar la compresión /archivo por archivo/ de forma
transparente al usuario.

Este esquema permite al administrador del sistema elegir, por archivos
o carpetas, qué areas del sistema de archivos desea almacenar
comprimidas; esta característica viene como parte de todos los
sistemas operativos Windows a partir de la versión *xp*, liberada en el
año 2003.

Si bien la compresión transparente por archivo se muestra mucho
más atractiva que la de volumen completo, no es una panacea y es
frecuente encontrar en foros en línea la recomendación de
deshabilitarla. En primer término, comprimir un archivo implica que un
cambio pequeño puede tener un efecto mucho mayor: modificar un bloque
puede implicar que el tamaño final de los datos cambie, lo cual se
traduciría a la reescritura del archivo desde ese punto en adelante;
esto podría mitigarse insertando espacios para preservar el espacio ya
ocupado, pero agrega complejidad al proceso (y abona en contra de la
compresión). Los archivos comprimidos son además mucho más sensibles a
la corrupción de datos, particularmente en casos de fallo de sistema o
de energía: dado que un cambio menor puede resultar en la necesidad de
reescribir al archivo completo, la ventana de tiempo para que se
produzca un fallo se incrementa.

En archivos estructurados para permitir el acceso aleatorio, como
podrían ser las tablas de bases de datos, la compresión implicaría que
los registros no estarán ya  alineados al tamaño que el
programa gestor espera, lo cual acarreará necesariamente una
penalización en el rendimiento y en la confiabilidad.

Por otro lado, los formatos nativos en que se expresan los datos que
típicamente ocupan más espacio en el almacenamiento de los usuarios
finales implican ya un alto grado de compresión: los archivos de
fotografías, audio o video se codifican bajo diversos
esquemas de compresión aptos para sus particularidades. Y comprimir un
archivo que ya está comprimido no sólo no reporta ningún
beneficio, sino que resulta en desperdicio de trabajo por el esfuerzo
invertido en descomprimirlo cada vez que es empleado.

La compresión transparente, archivo por archivo, tiene innegables
ventajas, sin embargo, por las desventajas que implica, no puede
tomarse como el modo de operación por omisión.

*** Desduplicación
# <<FS_desduplicacion>>

Hay una estrategia fundamentalmente distinta para optimizar el uso del
espacio de almacenamiento, logrando muy altos niveles de /sobreuso/:
guardar /sólo una copia/ de cada cosa.

Desde fines de los ochenta se han planteado sistemas implementando
distintos tipos de desduplicación, aunque su efectividad era muy
limitada y, por tanto, su nivel de adopción se mantuvo muy reducido
hasta recientemente.

El que se retomara la desduplicación se debe en buena medida a la
/consolidación/ de servidores ante la adopción a gran escala de
mecanismos de virtualización (véanse apéndice \ref{VIRT} y en
particular la sección \ref{VIRT_contenedores}). Dado que un mismo
servidor puede estar alojando a decenas o centenas de /máquinas
virtuales/, muchas de ellas con el mismo sistema operativo y programas
base, los mismos archivos se repiten muchas veces; si el sistema de
archivos puede determinar que cierto archivo o bloque está ya
almacenado, podría guardar sólamente una copia.

La principal diferencia entre la desduplicación y las /ligas duras/
mencionadas en la sección \ref{DIR_grafo_dirigido} es que, en caso
de que cualquiera de estos archivos (o bloques) sea modificado, el
sistema de archivos tomará el espacio necesario para representar estos
cambios y evitará que esto afecte a los demás archivos. Además, si dos
archivos inicialmente distintos se hacen iguales, se liberará el
espacio empleado por uno de ellos de forma automática.

Para identificar qué datos están duplicados, el mecanismo más
utilizado es calcular el /hash criptográfico/ de los datos;[fn:: Por
ejemplo, empleando el algoritmo *sha-256*, el cual brinda una
probabilidad de /colisión/ de 1 en $2^{256}$, suficientemente
confiable para que la pérdida de datos sea mucho menos probable que la
falla del disco.] este mecanismo permite una búsqueda rápida y
confiable de coincidencias, ya sea por archivo o por bloque.

La desduplicación puede realizarse /en línea/ o /fuera de línea/ —
esto es, analizar los datos buscando duplicidades al momento que estos
llegan al sistema, o (dado que es una tarea intensiva, tanto en uso de
procesador, como de entrada/salida) realizarla como una tarea posterior
de mantenimiento, en un momento de menor ocupación del sistema.

Desduplicar por archivo es mucho más ligero para el sistema que
hacerlo por bloque, aunque dadas las estructuras comunes que comparten
muchos archivos, desduplicar por bloque lleva típicamente a una mucho
mayor optimización del uso de espacio.

Al día de hoy, el principal sistema de archivos que implementa
desduplicación es *zfs*,[fn:: Las características básicas de *zfs* serán
presentadas en la sección \ref{FS_FIS_zfs}.] desarrollado por Sun
Microsystems (hoy Oracle). En Linux, esta característica forma parte
de *btrfs*, aunque no ha alcanzado los niveles de estabilidad como para
recomendarse para su uso en entornos de producción.

En Windows, esta funcionalidad se conoce como /single instance
storage/ (/almacenamiento de instancia única/). Esta característica
apareció, implementada en espacio de usuario y, por tanto, operando
únicamente por archivo, como una de las características del servidor
de correo /Exchange Server/ entre los años 2000 y 2010. A partir de
Windows Server 2003, la funcionalidad de desduplicación existe
directamente para *ntfs*, aunque su uso es poco frecuente.

El uso de desduplicación, particularmente cuando se efectúa por
bloques, tiene un alto costo en memoria: para mantener buenos niveles
de rendimiento, la tabla que relaciona el hash de datos con el sector
en el cual está almacenado debe mantenerse en memoria. En el caso de
la implementación de *zfs* en
#+latex: Free\textbf{bsd},
#+html: Free<b>bsd</b>,
la documentación sugiere dedicar 5 *gb* de memoria por cada *tb* de
almacenamiento (0.5% de la capacidad total) \parencite{FreeBSDZFS}.

** Sistemas de archivos virtuales

Los sistemas de archivos nacieron para facilitar el uso de
dispositivos de almacenamiento para la información que debe persistir
a largo plazo. Sin embargo, dado que la abstracción para su uso
resulta tan natural para representar todo tipo de información, desde
la década de los ochenta aparecieron diversas implementaciones de
discos *ram*: programas diseñados para tomar un espacio de memoria y
darle la semántica de un disco, permitiendo manipular su contenido
como si fuera un disco cualquiera. Esto es, presenta almacenamiento
volátil, pero de muy alta velocidad.

Estos esquemas gozaron de relativa popularidad a lo largo de los
ochenta y noventa; fue, sin embargo, con la popularización de los
sistemas que implementan memoria virtual que este esquema se volvió
verdaderamente popular. En los sistemas Linux modernos, la norma es el
uso de sistemas de archivos virtuales para el espacio de
almacenamiento temporal =/tmp=, e incluso otros espacios
tradicionalmente persistentes (como el directorio con los archivos de
dispositivos, =/dev=) se han convertido en virtuales.

*** Una ventana al núcleo
# <<FS_proc>>

El artículo titulado /Processes as files/ \parencite{Killian84},
presentado en el congreso de desarrolladores de sistemas Unix del
grupo *usenix*, presenta la implementación un sistema de archivos
virtual para ser montado en el directorio =/proc= del sistema. Dicho
sistema de archivos, en vez de representar un mapa de bloques en un
dispositivo físico, presentó una ventana a la lista de procesos en
ejecución en el sistema. El uso de =/proc= fue incorporado a
prácticamente todos los sistemas tipo Unix.

Esta idea ha avanzado y madurado, y al día de hoy es una herramienta
fundamental para la administración de sistemas. Si bien la propuesta
original de Killian estaba encaminada principalmente a facilitar la
implementación de depuradores presentando el espacio de memoria de los
procesos, =/proc= es hoy en día una suerte de ventana a estructuras
internas del sistema: un árbol de directorios con una gran cantidad de
archivos por medio de los cuales se puede monitorear el estado del
sistema (memoria libre, número de procesos, consumo de procesador,
etc.), e incluso modificar la configuración del sistema en ejecución.

Por ejemplo, en Linux, leer de =/proc/sys/vm/swappiness= dará, por
omisión, un valor de 60. Escribir el valor 100 a este archivo tendrá
por resultado inmediato que el sistema sea más /agresivo/ con la
paginación de memoria virtual, buscando dejar más espacio de memoria
física disponible (véase la sección \ref{MEM_virtual}) de lo que
normalmente haría. Por otro lado, escribir el valor uno tendrá por
efecto que el sistema operativo realice la paginación sólo si no tiene
otra alternativa. Un valor de cero tendrá como efecto el deshabilitar
la paginación por completo. Este archivo, al igual que todos los que
conforman =/proc=, se presenta ante los procesos en ejecución como un
archivo de tipo normal —la particularidad radica en el sistema de
archivos en que se ubica.

Claro está, por más que parezca una simple lectura de un archivo, el
leer o modificar un valor dentro de =/proc= cruza también por una
serie de llamadas al sistema; el que la configuración de la memoria
virtual esté disponible mediante algo que /parece ser/ un archivo (sin
serlo) es precisamente un caso de abstracción hacia una interfaz
consistente y conocida.

* Esquemas de asignación de espacio

Hasta este punto, la presentación de la /entrada de directorio/ se ha
limitado a indicar que ésta tiene un apuntador al lugar donde inicia
el espacio empleado por el archivo. No se ha detallado en cómo se
implementa la asignación y administración de dicho espacio. En esta
sección se hará un breve repaso de los tres principales mecanismos,
para después explicar cómo es la implementación de *fat*, abordando
sus principales virtudes y debilidades.

** Asignación contigua

Los primeros sistemas de archivos en disco empleaban un esquema de
/asignación contigua/. Para implementar un sistema de archivos de este
tipo, no haría falta contar con una /tabla de asignación de archivos/:
bastaría con la información que forma parte del directorio de *fat*
—la extensión del archivo y la dirección de su primer /cluster/.

#+attr_latex: width=0.7\textwidth
#+label: FS_fs_asignacion_contigua
#+caption: Asignación contigua de archivos: directorio con inicio y longitud.
[[./img/ditaa/fs_asignacion_contigua.png]]

La principal ventaja de este mecanismo de asignación, claro está, es
la simplicidad de su implementación. Brinda además la mejor velocidad
de transferencia del archivo, dado que al estar cada uno de los
archivos en espacio contiguo en el disco, el movimiento de cabezas se
mantiene al mínimo. Sin embargo, este mecanismo se vuelve sumamente
inconveniente en medios que soporten lectura y escritura: es muy
sensible a la /fragmentación externa/; si un archivo requiere crecer,
debe ser movido íntegramente a un bloque más grande (lo cual toma
demasiado tiempo), y el espacio que libera un archivo en caso de
reducirse su necesidad de espacio queda /atrapado/ entre bloques
asignados. Podemos tener mucho más espacio disponible que el que
podamos asignar a un nuevo archivo.

Los esquemas de asignación contigua se emplean hoy en día
principalmente en sistemas de archivo de sólo lectura, por ejemplo, lo
emplea el sistema principal que utilizan los *cd-rom*, *iso-9660*,
pensado para aprovechar al máximo un espacio que, una vez grabado,
sólo podrá abrirse en modo de sólo lectura. Esto explica porqué, a
diferencia de lo que ocurre en cualquier otro medio de almacenamiento,
al /quemar/ un *cd-rom* es necesario preparar primero una /imagen/ en
la que los archivos ocupen sus posiciones definitivas, y esta imagen
debe grabarse en el disco en una sola operación.

** Asignación ligada

Un enfoque completamente distinto sería el de /asignación
ligada/. Este esquema brinda mucho mayor flexibilidad al usuario,
sacrificando la simplicidad y la velocidad: cada entrada en el
directorio apunta a un primer /grupo/ de sectores (o /cluster/), y
éste contiene un apuntador que indica cuál es el siguiente.

Para hacer esto, hay dos mecanismos: el primero, reservar un espacio
al final de cada /cluster/ para guardar el apuntador y, el segundo,
crear una tabla independiente, que guarde únicamente los apuntadores.

En el primer caso, si se manejan /clusters/ de $2~048$ bytes, y se
reservan los cuatro bytes (32 bits) finales de cada uno, el resultado
sería de gran incomodidad a los programadores, ya que, frecuentemente,
buscan alinear sus operaciones con las fronteras de las estructuras
subyacentes, para optimizar los accesos (por ejemplo, evitar que un
sólo registro de base de datos requiera ser leído de dos distintos
bloques en disco). El programador tendría que diseñar sus estructuras
para ajustarse a la poco ortodoxa cantidad de $2~044$ bytes.

Y más allá de esta inconveniencia, guardar los apuntadores al final de
cada /cluster/ hace mucho más lento el manejo de todos los archivos:
al no tener en una sola ubicación la relación de /clusters/ que
conforman un archivo, todas las transferencias se convierten en
/secuenciales/: para llegar directamente a determinado bloque del
archivo, habrá que pasar por todos los bloques previos para encontrar
su ubicación.

Particularmente por este segundo punto es mucho más común el empleo de
una /tabla de asignación de archivos/ —y precisamente así es como
opera *fat* (de hecho, esta tabla es la que le da su nombre). La tabla
de asignación es un mapa de los /clusters/, representando a cada uno por
el espacio necesario para guardar un apuntador.

#+attr_latex: width=0.7\textwidth
#+label: FS_fs_asignacion_ligada
#+caption: Asignación ligada de archivos: directorio con apuntador sólo al primer /cluster/.
[[./img/ditaa/fs_asignacion_ligada.png]]

La principal ventaja del empleo de asignación ligada es que desaparece
la /fragmentación interna/.[fn:: Con /fragmentación interna/ se hace
aquí referencia al concepto presentado en la sección
\ref{MEM_fragmentacion}. El fenómeno generalmente conocido como
/fragmentación/ se refiere a la necesidad de /compactación/; es muy
distinto, y sí se presenta bajo este esquema: cada archivo se separa
en pequeños /fragmentos/ que pueden terminar esparcidos por todo el
disco, afectando fuertemente en el rendimiento del sistema.] Al ya no
requerir la /pre-asignación/ de un espacio contiguo, cada uno de los
archivos puede crecer o reducirse según sea necesario.

Ahora, la /asignación ligada/ no sólo resulta más lenta que la
contigua, sino que presenta una mayor /sobrecarga administrativa/: el
espacio desperdiciado para almacenar los apuntadores típicamente es
cercano a 1% del disponible en el medio.

Este esquema también presenta /fragilidad de metadatos/: si alguno de
los apuntadores se pierde o corrompe, lleva a que se pierda el archivo
/completo/ desde ese punto y hasta su final (y abre la puerta a la
corrupción de otro archivo, si el apuntador queda apuntando hacia un
bloque empleado por éste; el tema de fallos y recuperación bajo estos
esquemas se cubrirá en la sección \ref{FS_fallos_recuperacion}).

Hay dos mecanismos de mitigación para este problema: el empleado por
los sistemas *fat* es guardar una (o, bajo *fat12*, dos) copias
adicionales de la tabla de asignación, entre las cuales el sistema
puede verificar que se mantengan consistentes y buscar corregirlas en
caso contrario. Por otro lado, puede manejarse una estructura de
/lista doblemente ligada/ (en vez de una /lista ligada/ sencilla) en
que cada elemento apunte tanto al siguiente como al anterior, con lo
cual, en caso de detectarse una inconsistencia en la información, ésta
pueda ser recorrida /de atrás hacia adelante/ para confirmar los datos
correctos. En ambos casos, sin embargo, la sobrecarga administrativa
se duplica.

** Asignación indexada

El tercer modelo es la /asignación indexada/, el mecanismo empleado
por casi todos los sistemas de archivos modernos. En este esquema, se
crea una estructura intermedia entre el directorio y los datos, única
para cada archivo: el /i-nodo/ (o /nodo de información/). Cada uno
guarda los metadatos y la lista de bloques del archivo, reduciendo la
probabilidad de que se presente la /corrupción de apuntadores/
mencionada en la sección anterior.

#+attr_latex: width=0.9\textwidth
#+label: FS_fs_asignacion_indexada
#+caption: Asignación indexada de archivos: directorio con apuntador al i-nodo (ejemplificado con un i-nodo de tamaño extremadamente ineficiente).
[[./img/ditaa/fs_asignacion_indexada.png]]

La sobrecarga administrativa bajo este esquema potencialmente es mucho
mayor: al asignar el i-nodo, éste se crea ocupando como mínimo un
/cluster/ completo. En el caso de un archivo pequeño, que quepa en un
sólo /cluster/, esto representa un desperdicio de 100% de espacio (un
/cluster/ para el i-nodo y otro para los datos);[fn:: Algunos sistemas
de archivos, como Reiser, *btrfs* o *ufs*, presentan esquemas de
asignación /sub-cluster/. Estos denominan /colas/ (/tails/) a los
archivos muy pequeños, y pueden ubicarlos ya sea dentro de su mismo
i-nodo o compartiendo un mismo /cluster/ con un /desplazamiento/ dentro
de éste. Esta práctica no ha sido adoptada por sistemas de archivos de
uso mayoritario por su complejidad relativa.] para archivos más
grandes, la sobrecarga relativa disminuye, pero se mantiene siempre
superior a la de la asignación ligada.

Un esquema de asignación indexada brinda una mayor eficiencia de caché
que la asignación ligada: si bien en dicho caso es común guardar copia
de la tabla de asignación en memoria para mayor agilidad, con la
asignación indexada bastará hacer caché /sólo de la información
importante/, esto es, únicamente de los archivos que se emplean en un
momento dado. El /mapa de asignación/ para los archivos y directorios
que no hayan sido empleados recientemente no requerirán estar en
memoria.

Claro está, mientras que en los esquemas anteriores la tabla central
de asignación de archivos puede emplearse directamente como el
/bitmap/ del volumen, en los sistemas de archivos de asignación
indexada se vuelve necesario contar con un /bitmap/ independiente —
pero al sólo requerir representar si cada /cluster/ está vacío u
ocupado (y ya no apuntar al siguiente), resulta de mucho menor tamaño.

#+label: FS_fs_apuntadores_indirectos
#+caption: Estructura típica de un i-nodo en Unix, mostrando además el número de accesos a disco necesarios para llegar a cada /cluster/ (con sólo tres /cluster/ por lista).
#+attr_latex: width=0.8\textwidth
[[./img/dot/fs_apuntadores_indirectos.png]]

Ahora, ¿qué pasa cuando la lista de /clusters/ de un archivo no cabe
en un i-nodo? Este ejemplo se ilustra en el tercer archivo de la
figura \ref{FS_fs_apuntadores_indirectos}: en este caso, cada
i-nodo puede guardar únicamente tres apuntadores.[fn:: Esto resulta un
límite demasiado bajo, y fue elegido meramente para ilustrar el
presente punto.] Al tener un archivo con cuatro /clusters/, se hace
necesario extender al i-nodo con una lista adicional. La
implementación más común de este mecanismo es que, dependiendo del
tamaño del archivo, se empleen apuntadores con los niveles de
indirección que /vayan haciendo falta/.

¿Qué tan grande sería el archivo máximo direccionable bajo este
esquema y únicamente tres indirecciones? Suponiendo magnitudes típicas
hoy en día (/clusters/ de 4 *kb* y direcciones de 32 bits), en un
/cluster/ vacío caben 1024 apuntadores ($4~096 \over 4$). Si los
metadatos ocupan 224 bytes en el i-nodo, dejando espacio para 968
apuntadores:

- Un archivo de hasta $(968-3) \times 4$ *kb* = 3860 *kb* puede ser referido
  por completo directamente en el i-nodo, y es necesario un sólo
  acceso a disco para obtener su lista de /clusters/.
- Un archivo de hasta $(968-3 + 1024) \times 4$ *kb* = 7956 *kb* puede
  representarse con el bloque de indirección sencilla, y obtener su
  lista de /clusters/ significa dos accesos a disco adicionales.
- Con el bloque de doble indirección, puede hacerse referencia a
  archivos mucho más grandes:

  $(968-3 + 1024 + (1024\times 1024) ) \times 4$ *kb* $= 4~202~260$ *kb*
  $\approx 4$ *gb*

  Sin embargo, a estas alturas comienza a llamar la atención otro
  importante punto: para acceder a estos 65 *mb*, es necesario
  realizar hasta 1027 accesos a disco. A partir de este punto, resulta
  importante que el sistema operativo asigne /clusters/ cercanos para
  los metadatos (y, de ser posible, para los datos), pues la
  diferencia en tiempo de acceso puede ser muy grande.

- Empleando triple indirección, se puede llegar hasta:

  $(968-3 + 1024 + (1024 \times 1024) + (1024 \times 1024 \times 1024) )
  \times 4$ *kb* $= 4~299~169~556 *kb* \approx 4$ *tb*

  Esto es ya más de lo que puede representarse en un sistema de 32
  bits. La cantidad de bloques a leerse, sin embargo, para encontrar
  todos los /clusters/ significarían hasta $16~516$ accesos a disco (en
  el peor de los casos).

** Las tablas en *fat*
# <<FS_tablas_fat>>

Volviendo al caso que se presenta como ejemplo, para el sistema de
archivos *fat*, cada entrada del directorio apunta al primer /cluster/
que ocupa cada uno de los archivos, y se emplea un esquema de
asignación ligada. El directorio tiene también un campo indicando la
/longitud total/ del archivo, pero esto no es empleado para leer la
información, sino para poderla presentar más ágilmente al usuario (y
para que el sistema operativo sepa dónde indicar /fin de archivo/ al
leer el último /cluster/ que compone a determinado archivo).

La estructura fundamental de este sistema de archivos es la tabla de
asignación de archivos (/file allocation table/) — tanto que de ella
toma el nombre por el cual se le conoce, *fat*.

Cada entrada de la *fat* mide lo que la longitud correspondiente a su
versión (12, 16 o 32 bits), y almacena ya sea el siguiente /cluster/
del archivo, o alguno de los valores especiales descritos en el cuadro
\ref{FS_valores_especiales_fat}.

#+caption: Valores especiales que puede almacenar *fat*; cualquier otro valor indica la dirección del siguiente /cluster/ que forma parte del archivo al cual pertenece el registro en cuestión.
#+label: FS_valores_especiales_fat
| *fat12* | *fat16*  | *fat32*      | Significado                           |
|---------+----------+--------------+---------------------------------------|
| =0x000= | =0x0000= | =0x00000000= | Disponible, puede ser asignado.       |
| =0xFF7= | =0xFFF7= | =0xFFFFFFF7= | /Cluster/ dañado, no debe utilizarse. |
| =0xFFF= | =0xFFFF= | =0xFFFFFFFF= | Último /cluster/ de un archivo.       |
|---------+----------+--------------+---------------------------------------|

Llama la atención que haya un valor especial para indicar que un
/cluster/ tiene sectores dañados. Esto remite de vuelta al momento
histórico de la creación de la familia *fat*: siendo el medio
predominante de almacenamiento el disco flexible, los errores en la
superficie eran mucho más frecuentes de lo que lo son hoy en día.

Una característica que puede llamar la atención de *fat* es que
parecería permitir la fragmentación de archivos /por diseño/: dado que
el descriptor de cada /cluster/ /debe apuntar/ al siguiente, puede
asumirse que el /caso común/ es que los /clusters/ no ocuparán contiguos
en el disco. Claro está, la tabla puede apuntar a varios /clusters/
adyacentes, pero el sistema de archivos mismo no hace nada para que
así sea.

#+label: FS_img_tabla_fat
#+caption: Ejemplo de entradas en la tabla de asignación de archivos en *fat32*.
#+attr_latex: width=\textwidth
#+attr_html: width="628" height="284"
[[./img/tabla_fat.png]]

En la sección \ref{FS_el_directorio}, al presentar el formato del
directorio de *fat*, se mencionó que los subdirectorios son en
realidad archivos de un tipo especial: una suerte de archivos
estructurados (véase la sección \ref{DIR_archivos_estructurados}),
gestionados por el sistema operativo. Lo único que distingue a un
directorio de un archivo normal es que, en la entrada que lo describe
en su directorio padre, el doceavo byte de la entrada (que indica los
/atributos del archivo/, véanse la figura
\ref{FS_entrada_directorio_fat} y el cuadro 7.1) tiene activado el
bit cuatro.

Un directorio es almacenado en disco /exactamente/ como cualquier otro
archivo. Si se le asigna únicamente un /cluster/, y el tamaño del
/cluster/ es pequeño (2 *kb*), podrá almacenar sólo 64 entradas
($2~048 \over 32$) y cada /cluster/ adicional le dará 64 entradas
más. Y dado que es tratado tal cual si fuera un archivo normal, estará
sujeto también a la fragmentación: conforme se agreguen entradas al
directorio, éste crecerá. Llegado el momento, requerirá /clusters/
adicionales. Y si un directorio termina disperso por todo el disco,
resultará –como cualquier otro archivo– más lento leerlo y trabajar
con él. Siempre que se abra un archivo dentro de un directorio grande,
o que se le recorra para abrir algún archivo en un subdirectorio suyo,
el sistema tendrá que buscar todos sus fragmentos a lo largo del
disco.

Ante estos dos aspectos, no puede perderse de vista la edad que tiene
el sistema *fat*. Otros sistemas de archivos más modernos han resuelto
este problema mediante los /grupos de asignación/: los directorios del
sistema son /esparcidos/ a lo largo del volumen, y /se intenta/ ubicar
los archivos cerca de los directorios desde donde son referidos.[fn::
Claro está, en el caso de los archivos que están como /ligas duras/
desde varios directorios, pueden ubicarse sólo cerca de uno de ellos.]
Esto tiene como consecuencia que los archivos que presentan /cercanía
temática/ (que pertenecen al mismo usuario o proyecto, o que por
alguna razón están en la misma parte de la jerarquía del sistema)
quedan ubicados en disco cerca unos de otros (y cerca de sus
directorios). Y dado que es probable que sean empleados
aproximadamente al mismo tiempo, esto reduce las distancias que
recorrerán las cabezas. Además, al esparcir los archivos, se
distribuye también mejor el espacio libre, por lo cual el efecto de
los cambios de tamaño de un archivo en lo relativo a la fragmentación
se limita a los que forman parte del mismo bloque de asignación.

Los sistemas de archivos que están estructurados siguiendo esta lógica
de grupos de asignación no evitan la fragmentación, pero sí la mayor
parte de sus consecuencias negativas. Para mantener este esquema
operando confiablemente, eso sí, requieren de mantener disponibilidad
de espacio — al presentarse saturación, esta estrategia pierde
efectividad. Para evitar que esto ocurra, es muy frecuente en los
sistemas Unix que haya un cierto porcentaje (típicamente cercano a 5%)
del disco disponible únicamente para el administrador — en caso de que
el sistema de archivos pase de 95%, los usuarios no podrán escribir en
él, pero el administrador puede efectuar tareas de mantenimiento para
volver a un rango operacional.

* Fallos y recuperación
# <<FS_fallos_recuperacion>>

El sistema de archivos *fat* es /relativamente frágil/: no es difícil
que se presente una situación de /corrupción de metadatos/, y muy
particularmente, que ésta afecte la estructura de las tablas de
asignación. Los usuarios de sistemas basados en *fat* en Windows sin
duda conocen a =CHKDSK= y =SCANDISK=, dos programas que implementan la
misma funcionalidad base, y difieren principalmente en su interfaz al
usuario: =CHKDSK= existe desde los primeros años de *ms-dos*, y está
pensado para su uso interactivo en línea de comando; =SCANDISK= se
ejecuta desde el entorno gráfico, y presenta la particularidad de que
no requiere (aunque sí recomienda fuertemente) /acceso exclusivo/ al
sistema de archivos mientras se ejecuta.

¿Cómo es el funcionamiento de estos programas?

A lo largo de la vida de un sistema de archivos, conforme los archivos
se van asignando y liberando, cambian su tamaño, y conforme el sistema
de archivos se monta y desmonta, pueden ir apareciendo
/inconsistencias/ en su estructura. En los sistemas tipo *fat*, las
principales inconsistencias[fn:: Que no las únicas. Éstas y otras más
están brevemente descritas en la página de manual de =dosfsck= (véase
la sección \ref{FS_otros_recursos}).] son:

- Archivos cruzados :: (/cross-linked file/) Recuérdese que la entrada
     en el directorio de un archivo incluye un apuntador al primer
     /cluster/ de una /cadena/. Cada cadena debe ser única, esto es,
     ningún /cluster/ debe pertenecer a más de un archivo. Si dos
     archivos incluyen al mismo /cluster/, esto indica una
     inconsistencia, y la única forma de resolverla es /truncar/ uno
     de los archivos en el punto inmediato anterior a este cruce.

- Cadenas perdidas o /huérfanas/ :: (/lost clusters/) Cuando hay
     espacio marcado como ocupado en la tabla de asignación, pero no
     hay ninguna entrada de directorio haciendo referencia a ella, el
     espacio está efectivamente bloqueado y, desde la perspectiva del
     usuario, inutilizado; además, estas cadenas pueden ser un archivo
     que el usuario aún requiera.

     Este problema resultó tan frecuente en versiones históricas de
     Unix que incluso hoy es muy común tener un directorio llamado
     =lost+found= en la raíz de todos los sistemas de archivos, donde
     =fsck= (el equivalente en Unix de =CHKDSK=) creaba ligas a los
     archivos perdidos por corrupción de metadatos.

Cada sistema de archivos podrá presentar un distinto conjunto de
inconsistencias, dependiendo de sus estructuras
básicas y de la manera en que cada sistema operativo las maneja.

#+attr_latex: width=0.7\textwidth
#+label: FS_inconsistencias_fat
#+caption: Inconsistencias en un sistema de archivos tipo *fat*.
[[./img/dot/inconsistencias_fat.png]]

En la década de los 1980 comenzaron a venderse los /controladores de
disco inteligentes/, y en menos de 10 años dominaban ya el
mercado. Estos controladores, con interfaces físicas tan disímiles
como *scsi*, *ide*, o los más modernos, *sas* y *sata*, introdujeron
muchos cambios que fueron disociando cada vez más al sistema operativo
de la gestión física directa de los dispositivos; en el apéndice
\ref{FS_FIS} se presenta con mayor profundidad lo que esto ha
significado para el desarrollo de sistemas de archivos y algoritmos
relacionados. Sin embargo, para el tema en discusión, los
/controladores inteligentes/ resultan relevantes porque, si bien antes
el sistema operativo podía determinar con toda certeza si una
operación se había realizado o no, hoy en día los controladores dan un
/acuse de recibo/ a la información en el momento en que la colocan en
el caché incorporado del dispositivo —en caso de un fallo de
corriente, esta información puede no haber sido escrita por completo
al disco.

Es importante recordar que las operaciones con los metadatos que
conforman el sistema de archivos no son atómicas. Por poner un
ejemplo, crear un archivo en un volumen *fat* requiere:

1. Encontrar una lista de /clusters/ disponibles suficiente para
   almacenar la información que conformará al archivo.
2. Encontrar el siguiente espacio disponible en el directorio.
3. Marcar en la tabla de asignación la secuencia de /clusters/ que
   ocupará el archivo.
4. Crear en el espacio encontrado una entrada con el nombre del
   archivo, apuntando al primero de sus /clusters/.
5. Almacenar los datos del archivo en cuestión en los /clusters/
   determinados en el paso 1.

Cualquier fallo que se presente después del tercer paso (tras
efectuarse la primera modificación) tendrá como consecuencia que el
archivo resulte corrupto, y muy probablemente todo que el sistema de
archivos /presente inconsistencias/ o /esté en un estado
inconsistente/.

** Datos y metadatos

En el ejemplo recién presentado, el sistema de archivos estará en un
estado consistente siempre que se terminen los pasos 3 y 4 —la
consistencia del sistema de archivos es independiente de la validez de
los datos del archivo. Lo que busca el sistema de archivos, más que
garantizar la integridad de los /datos/ de uno de los archivos, es
asegurar la de los /metadatos/: los datos que describen la estructura.

En caso de que un usuario desconecte una unidad a media
operación, es muy probable que se presente pérdida de información,
pero el sistema de archivos debe buscar no presentar ningún problema
que ponga en riesgo /operaciones posteriores/ o /archivos no
relacionados/. La corrupción y recuperación de datos en archivos
corruptos y truncados, si bien es también de gran importancia, cae más
bien en el terreno de las aplicaciones del usuario.

** Verificación de la integridad

Cada sistema operativo incluye programas para realizar verificación
(y, en su caso, corrección) de la integridad de sus sistemas de
archivo. En el caso de *ms-dos* y Windows, como ya se vio, estos
programas son =CHKDSK= y =SCANDISK=; en los sistemas Unix, el programa
general se llama =fsck=, y típicamente emplea a asistentes según el
tipo de sistema que haya que revisar — =fsck.vfat=, =fsck.ext2=,
etcétera.

Estos programas hacen un /barrido/ del sistema de archivos, buscando
evidencias de inconsistencia. Esto lo hacen, en líneas generales:

- Siguiendo todas las cadenas de /clusters/ de archivos o tablas de
  i-nodos, y verificando que no haya archivos cruzados (compartiendo
  erróneamente bloques).
- Verificando que todas las cadenas de /clusters/, así como todos los
  directorios, sean alcanzables y sigan una estructura válida.
- Recalculando la correspondencia entre las estructuras encontradas y
  los diferentes bitmaps y totales de espacio vacío.

Estas operaciones son siempre procesos intensivos y complejos. Como
requieren una revisión profunda del volumen entero, es frecuente que
duren entre decenas de minutos y horas. Además, para poder llevar a
cabo su tarea deben ejecutarse teniendo acceso exclusivo al volumen a
revisar, lo cual típicamente significa colocar al sistema completo en
modo de mantenimiento.

Dado el elevado costo que tiene verificar el volumen entero, en la
década de los noventa surgieron varios esquemas orientados a evitar la
necesidad de invocar a estos programas de verificación: las
/actualizaciones suaves/, los /sistemas de archivos con bitácora/, y
los /sistemas de archivos estructurados en bitácora/.

** Actualizaciones suaves

El esquema de /actualizaciones suaves/ (/soft updates/) aparentemente
es el más simple de los que se presentan, pero su implementación
resultó mucho más compleja de lo inicialmente estimado y, en buena
medida, por esta causa no ha sido empleado más ampliamente. La idea
básica detrás de este esquema es estructurar el sistema de archivos de
una forma más simple y organizar las escrituras del mismo de modo que
el estado resultante /no pueda/ ser inconsistente, ni siquiera en caso
de fallo, y de exigir que todas las operaciones de actualización de
metadatos se realicen de forma /síncrona/.[fn:: Esto es, no se le
reporta éxito en alguna operación de archivos al usuario sino hasta
que ésta es completada y grabada a disco.]

Ante la imposibilidad de tener un sistema /siempre consistente/, esta
exigencia se relajó para permitir inconsistencias /no destructivas/:
pueden presentarse /cadenas perdidas/, dado que esto no pone en
riesgo a ningún archivo, sólo disminuye el espacio total disponible.

Esto, aunado a una reestructuración del programa de verificación
(=fsck=) como una tarea /ejecutable en el fondo/[fn:: Una tarea que no
requiere de intervención manual por parte del operador, y se efectúa
de forma automática como parte de las tareas de mantenimiento del
sistema.] y en una tarea de
/recolector de basura/, que no requiere intervención humana (dado que
no pueden presentarse inconsistencias destructivas), permite que un
sistema de archivos que no fue /limpiamente desmontado/ pueda ser
montado y utilizado de inmediato, sin peligro de pérdida de
información o de corrupción.

Al requerir que todas las operaciones sean síncronas, parecería que el
rendimiento global del sistema de archivos tendría que verse afectado,
pero por ciertos patrones de acceso muy frecuentes, resulta incluso
beneficioso. Al mantenerse un ordenamiento lógico entre las
dependencias de todas las operaciones pendientes, el sistema operativo
puede /combinar/ muchas de estas y reducir de forma global las
escrituras a disco.

A modo de ejemplos: si varios archivos son creados en el mismo
directorio de forma consecutiva, cada uno de ellos mediante una
llamada =open()= independiente, el sistema operativo combinará todos
estos accesos en uno solo, reduciendo el número de llamadas. Por otro
lado, un patrón frecuente en sistemas Unix es que, para crear un
archivo de uso temporal reforzando la confidencialidad de su
contenido, el proceso solicite al sistema la creación de un archivo,
abra el archivo recién creado, y ya teniendo al descriptor de archivo,
lo elimine —en este caso, con estas tres operaciones seguidas, /soft
updates/ podría ahorrarse por completo la escritura a disco.

Esta estrategia se vio afectada por los controladores inteligentes:
si un disco está sometido a carga intensa, no hay garantía para el
sistema operativo del orden que seguirán /en verdad/ sus solicitudes,
que se /forman/ en el caché propio del disco. Dado que las
actualizaciones suaves dependen tan profundamente de confiar en el
ordenamiento, esto rompe por completo la confiabilidad del proceso.

Las actualizaciones suaves fueron implementadas hacia 2002 en el
sistema operativo
#+latex: Free\textbf{bsd},
#+html: Free<b>bsd</b>,
y fueron adoptadas por los principales sistemas de la familia *bsd*,
aunque
#+latex: Net\textbf{bsd}
#+html: Net<b>bsd</b>
lo retiró en 2012, prefiriendo el empleo de sistemas con bitácora,
tema que será tratado a continuación. Muy probablemente, la lógica
detrás de esta decisión sea la cantidad de sistemas que emplean esta
segunda estrategia, y lo complejo que resulta dar mantenimiento dentro
del núcleo a dos estrategias tan distintas.

** Sistemas de archivo con bitácora

Este esquema tiene su origen en el ámbito de las bases de datos
distribuidas. Consiste en separar un área del volumen y dedicarla a
llevar una bitácora (/journal/) con todas las /transacciones/ de
metadatos.[fn:: Hay implementaciones que registran también los datos
en la bitácora, pero tanto por el tamaño que ésta requiere como por el
efecto en velocidad que significa, son poco utilizadas. La sección
\ref{FS_log_structured} presenta una idea que elabora sobre una
bitácora que almacena tanto datos como metadatos.] Una /transacción/
es un conjunto de operaciones que deben aparecer como atómicas.

La bitácora se implementa generalmente como una /lista ligada
circular/, con un apuntador que indica cuál fue la última operación
realizada exitosamente. Periódicamente, o cuando la carga de
transferencia de datos disminuye, el sistema verifica qué operaciones
quedaron pendientes, y /avanza/ sobre la bitácora, marcando cada una
de las transacciones conforme las realiza.

En caso de tener que recuperarse de una condición de fallo, el
sistema operativo sólo tiene que leer la bitácora, encontrar cuál fue
la última operación efectuada, y aplicar las restantes.

Una restricción de este esquema es que las transacciones guardadas en
la bitácora deben ser /idempotentes—/ esto es, si una de ellas es
efectuada dos veces, el efecto debe ser exactamente el mismo que si
hubiera sido efectuada una sola vez. Por poner un ejemplo, no sería
válido que una transacción indicara "agregar al directorio /x/ un
archivo llamado /y/", dado que si la falla se produce después de
procesar esta transacción pero antes de avanzar al apuntador de la
bitácora, el directorio /x/ quedaría con dos archivos /y/ —una
situación inconsistente. En todo caso, tendríamos que indicar
"registrar al archivo /y/ en la posición /z/ del directorio /x/"; de
esta manera, incluso si el archivo ya había sido registrado, puede
volverse a hacerlo sin peligro.

#+attr_latex: width=\textwidth
#+label: FS_fs_journaling
#+caption: Sistema de archivos con bitácora.
[[./img/dot/fs_journaling.png]]

Este esquema es el más utilizado hoy en día, y está presente en casi
todos los sistemas de archivos modernos. Si bien con un sistema con
bitácora no hace falta verificar el sistema de archivos completo tras
una detención abrupta, esta no exime de que, de tiempo en tiempo, el
sistema de archivos sea verificado: es altamente recomendado hacer una
verificación periódica en caso de presentarse alguna corrupción, sea
por algún bug en la implementación, fallos en el medio físico, o
factores similarmente poco frecuentes.

La mayor parte de los sistemas de archivos incluyen contadores de
/cantidad de montajes/ y de /fecha del último montaje/, que permiten
que el sistema operativo determine, automáticamente, si corresponde
hacer una verificación preventiva.

** Sistemas de archivos estructurados en bitácora
# <<FS_log_structured>>
Si se lleva el concepto del sistema de archivos con bitácora a su
límite, y se designa a /la totalidad/ del espacio en el volumen como
la bitácora, el resultado es un sistema de archivos /estructurado en
bitácora/ (/log-structured file systems/). Obviamente, este tipo de
sistemas de archivos presenta una organización completa radicalmente
diferente de los sistemas de archivo tradicionales.

Las ideas básicas detrás de la primer implementación de un sistema de
archivos de esta naturaleza (Ousterhut y Rosenblum, 1992) apuntan al
empleo agresivo de caché de gran capacidad, y con un fuerte mecanismo
de /recolección de basura/, reacomodando la información que esté más
cerca de la /cola/ de la bitácora (y liberando toda aquella que
resulte redundante).

Este tipo de sistemas de archivos facilita las escrituras, haciéndolas
siempre secuenciales, y buscan –por medio del empleo del caché ya
mencionado– evitar que las cabezas tengan que desplazarse con
demasiada frecuencia para recuperar fragmentos de archivos.

Una consecuencia directa de esto es que los sistemas de archivos
estructurados en bitácora fueron los primeros en ofrecer /fotografías/
(/snapshots/) del sistema de archivos: es posible apuntar a un
momento en el tiempo, y –con el sistema de archivos aún en operación–
montar una copia de sólo lectura con la información del sistema de
archivos /completa/ (incluyendo los datos de los archivos).

Los sistemas de archivo estructurados en bitácora, sin embargo, no
están optimizados para cualquier carga de trabajo. Por ejemplo, una
base de datos relacional, en que cada uno de los registros es
típicamente actualizado de forma independiente de los demás, y ocupan
apenas fracciones de un bloque, resultaría tremendamente
ineficiente. La implementación referencia de Ousterhut y Rosenblum fue
parte de los sistemas *bsd*, pero dada su tendencia a la /extrema
fragmentación/, fue eliminado de ellos.

Este tipo de sistemas de archivo ofrece características muy
interesantes, aunque es un campo que aún requiere de mucha
investigación e implementaciones ejemplo. Muchas de las
implementaciones en sistemas libres han llegado a niveles de
funcionalidad aceptables, pero por diversas causas han ido perdiendo
el interés o el empuje de sus desarrolladores, y su ritmo de
desarrollo ha decrecido. Sin embargo, varios conceptos muy
importantes han nacido bajo este tipo de sistemas de archivos,
algunos de los cuales (como el de las /fotografías/) se han ido
aplicando a sistemas de archivo estándar.

Por otro lado, dado el fuerte crecimiento que están registrando los
medios de almacenamiento de estado sólido (en la sección
\ref{FS_FIS_estado_solido} se abordarán algunas de sus
particularidades), y dado que estos sistemas logran aprovechan mejor
varias de sus características, es probable que el interés en estos
sistemas de archivos resurja.

* Ejercicios

** Preguntas de autoevaluación

1. Asuma el siguiente sistema de archivos basado en /asignación
   indexada/. Cada /cluster/ mide $4~096$ bytes, y el apuntador a un
   bloque requiere 32 bits (4 bytes). Dados los metadatos que van a
   almacenarse en el i-nodo del archivo, dentro del i-nodo principal
   puede guardar 24 apuntadores directos, y está considerando permitir
   indirección sencilla y doble.

   ¿Cuál es el tamaño máximo de archivo que podrá manejar este sistema
   de archivos?

2. El sistema de archivos /Reiser/ está basado en la /asignación
   indexada/, pero introduce un nuevo concepto: las /colitas/
   (/tails/). Éstas permiten que distintos archivos pequeños, de hasta
   4 *kb*, puedan ser almacenados /en un mismo cluster/. Esto permite a
   Reiser ahorrar espacio en disco (se estima que logra una eficiencia
   hasta 5% mayor que sistemas que no emplean esta técnica), y además
   reduce el tiempo requerido para recuperar estos archivos, dado que
   los datos pueden almacenarse en el mismo i-nodo que alguna de sus
   bibliotecas, sin requerir leer ningún bloque adicional.

   Reiser se popularizó alrededor del 2001, pero su desarrollo se ha
   detenido, y esta característica en particular no ha sido adoptada
   más que por unos pocos sistemas de archivos (*ufs2* y *btrfs*). ¿Qué
   problemas encuentra con el planteamiento de las /colitas/?

3. Describa el funcionamiento de un /sistema de archivos con bitácora/
   (/journaling file system/). ¿Cómo nos asegura que el sistema se
   mantendrá consistente después de una interrupción abrupta del
   suministro eléctrico?

** Temas de investigación sugeridos

- Desduplicación ::

  Una de las características que ofrecen varios sistemas operativos de
  última generación es la /desduplicación/, presentada en la sección
  \ref{FS_desduplicacion}: la detección de sectores idénticos
  pertenecientes a más de un archivo, para evitar repetirlos varias
  veces en el disco (es un fenómeno que ocurre mucho más de lo que
  esperaríamos). Esta detección se realiza típicamente por medio de
  /hashes criptográficos/.

  ¿Cómo opera un poco más a detalle este mecanismo, qué tan confiable
  es? (esto es, ¿se recomienda utilizar ya en sistemas en producción?)
  ¿Qué tan eficiente resulta con los datos que se encuentran
  típicamente, qué pasa con el espacio libre reportado al sistema, no
  se cae en riesgos de /sobrecomprometimiento/ (/overcommit/)?
  Respecto a su forma de operación, ¿qué diferencias tienen la
  /desduplicación en línea/ y la /desduplicación fuera de línea/
  (/online deduplication/, /offline deduplication/), Cómo opera el
  /hash criptográfico/? Y de forma general, ¿hay veces que este
  mecanismo resulte insuficiente, qué alternativas hay?

  Como referencia informal al respecto, léase el siguiente hilo
  de discusión al respecto en la lista de DebConf (el Congreso de
  Debian):

  #+latex: { \tt \href{http://lists.debconf.org/lurker/message/20130813.100610.f38cd67f.en.html}{http://lists.debconf.org/lurker/message/\\20130813.100610.f38cd67f.en.html}}

** Lecturas relacionadas
# <<FS_otros_recursos>>

- \fullcite{Giampaolo1999}. El autor fue parte del equipo que
  implementó el sistema operativo
  #+latex: Be\textbf{os},
  #+html: Be<b>os</b>,
  un sistema de alto rendimiento
  pensado para ejecutar en estaciones de alto rendimiento,
  particularmente enfocado al video. El proyecto fracasó a la larga, y
  #+latex: Be\textbf{os} (así como Be\textbf{fs},
  #+html: Be<b>os</b> (así como Be<b>fs</b>,
  el sistema que describe) ya no se utilizan. Este libro, descargable
  desde el sitio Web de su autor, tiene una muy buena descripción de
  varios sistemas de archivos, y aborda a profundidad técnicas que
  hace 15 años eran verdaderamente novedosas y hoy forman parte de
  casi todos los sistemas de archivos con uso amplio, e incluso
  algunas que no se han logrado implementar y que BeFS sí ofrecía.
- \fullcite{Killian84}
- \fullcite{Huffman52}
- \fullcite{Mohammed2007}
- \fullcite{Clark2001}
- \fullcite{McKusick1984}
- \fullcite{McKusick2012}
  - Traducción al español: \fullcite{CesarYanez2013}
- \fullcite{Rosenblum1992}
- \fullcite{Poirier2011}
- \fullcite{Yanez2012}
- \fullcite{CorbetBtrfsDoS},
- \fullcite{ApacheCacheExt3}. Reporte de fallo de Debian ilustrando
  los límites en números de archivos para Ext3.
- \fullcite{Heidemann1994}
- \fullcite{Anderson1996}
- \fullcite{Aurora2009}
